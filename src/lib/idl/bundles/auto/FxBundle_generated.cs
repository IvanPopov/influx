// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace Fx
{

using global::System;
using global::System.Collections.Generic;
using global::FlatBuffers;

public enum RoutineBundle : byte
{
  NONE = 0,
  RoutineBytecodeBundle = 1,
  RoutineShaderBundle = 2,
};

public class RoutineBundleUnion {
  public RoutineBundle Type { get; set; }
  public object Value { get; set; }

  public RoutineBundleUnion() {
    this.Type = RoutineBundle.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public Fx.RoutineBytecodeBundleT AsRoutineBytecodeBundle() { return this.As<Fx.RoutineBytecodeBundleT>(); }
  public static RoutineBundleUnion FromRoutineBytecodeBundle(Fx.RoutineBytecodeBundleT _routinebytecodebundle) { return new RoutineBundleUnion{ Type = RoutineBundle.RoutineBytecodeBundle, Value = _routinebytecodebundle }; }
  public Fx.RoutineShaderBundleT AsRoutineShaderBundle() { return this.As<Fx.RoutineShaderBundleT>(); }
  public static RoutineBundleUnion FromRoutineShaderBundle(Fx.RoutineShaderBundleT _routineshaderbundle) { return new RoutineBundleUnion{ Type = RoutineBundle.RoutineShaderBundle, Value = _routineshaderbundle }; }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, RoutineBundleUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case RoutineBundle.RoutineBytecodeBundle: return Fx.RoutineBytecodeBundle.Pack(builder, _o.AsRoutineBytecodeBundle()).Value;
      case RoutineBundle.RoutineShaderBundle: return Fx.RoutineShaderBundle.Pack(builder, _o.AsRoutineShaderBundle()).Value;
    }
  }
}

public enum RoutineSourceBundle : byte
{
  NONE = 0,
  RoutineGLSLSourceBundle = 1,
  RoutineHLSLSourceBundle = 2,
};

public class RoutineSourceBundleUnion {
  public RoutineSourceBundle Type { get; set; }
  public object Value { get; set; }

  public RoutineSourceBundleUnion() {
    this.Type = RoutineSourceBundle.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public Fx.RoutineGLSLSourceBundleT AsRoutineGLSLSourceBundle() { return this.As<Fx.RoutineGLSLSourceBundleT>(); }
  public static RoutineSourceBundleUnion FromRoutineGLSLSourceBundle(Fx.RoutineGLSLSourceBundleT _routineglslsourcebundle) { return new RoutineSourceBundleUnion{ Type = RoutineSourceBundle.RoutineGLSLSourceBundle, Value = _routineglslsourcebundle }; }
  public Fx.RoutineHLSLSourceBundleT AsRoutineHLSLSourceBundle() { return this.As<Fx.RoutineHLSLSourceBundleT>(); }
  public static RoutineSourceBundleUnion FromRoutineHLSLSourceBundle(Fx.RoutineHLSLSourceBundleT _routinehlslsourcebundle) { return new RoutineSourceBundleUnion{ Type = RoutineSourceBundle.RoutineHLSLSourceBundle, Value = _routinehlslsourcebundle }; }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, RoutineSourceBundleUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case RoutineSourceBundle.RoutineGLSLSourceBundle: return Fx.RoutineGLSLSourceBundle.Pack(builder, _o.AsRoutineGLSLSourceBundle()).Value;
      case RoutineSourceBundle.RoutineHLSLSourceBundle: return Fx.RoutineHLSLSourceBundle.Pack(builder, _o.AsRoutineHLSLSourceBundle()).Value;
    }
  }
}

public enum EPartSimRoutines : short
{
  k_Reset = 0,
  k_Spawn = 1,
  k_Init = 2,
  k_Update = 3,
  k_Last = 4,
};

public enum EPartRenderRoutines : short
{
  k_Prerender = 0,
  k_Vertex = 1,
  k_Pixel = 2,
  k_Last = 3,
};

public enum EMatRenderRoutines : short
{
  k_Vertex = 0,
  k_Pixel = 1,
  k_Last = 2,
};

public enum BundleContent : byte
{
  NONE = 0,
  PartBundle = 1,
  MatBundle = 2,
  Technique11Bundle = 3,
};

public class BundleContentUnion {
  public BundleContent Type { get; set; }
  public object Value { get; set; }

  public BundleContentUnion() {
    this.Type = BundleContent.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public Fx.PartBundleT AsPartBundle() { return this.As<Fx.PartBundleT>(); }
  public static BundleContentUnion FromPartBundle(Fx.PartBundleT _partbundle) { return new BundleContentUnion{ Type = BundleContent.PartBundle, Value = _partbundle }; }
  public Fx.MatBundleT AsMatBundle() { return this.As<Fx.MatBundleT>(); }
  public static BundleContentUnion FromMatBundle(Fx.MatBundleT _matbundle) { return new BundleContentUnion{ Type = BundleContent.MatBundle, Value = _matbundle }; }
  public Fx.Technique11BundleT AsTechnique11Bundle() { return this.As<Fx.Technique11BundleT>(); }
  public static BundleContentUnion FromTechnique11Bundle(Fx.Technique11BundleT _technique11bundle) { return new BundleContentUnion{ Type = BundleContent.Technique11Bundle, Value = _technique11bundle }; }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, BundleContentUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case BundleContent.PartBundle: return Fx.PartBundle.Pack(builder, _o.AsPartBundle()).Value;
      case BundleContent.MatBundle: return Fx.MatBundle.Pack(builder, _o.AsMatBundle()).Value;
      case BundleContent.Technique11Bundle: return Fx.Technique11Bundle.Pack(builder, _o.AsTechnique11Bundle()).Value;
    }
  }
}

public enum PropertyValue : byte
{
  NONE = 0,
  UintValue = 1,
  IntValue = 2,
  FloatValue = 3,
  StringValue = 4,
};

public class PropertyValueUnion {
  public PropertyValue Type { get; set; }
  public object Value { get; set; }

  public PropertyValueUnion() {
    this.Type = PropertyValue.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public Fx.UintValueT AsUintValue() { return this.As<Fx.UintValueT>(); }
  public static PropertyValueUnion FromUintValue(Fx.UintValueT _uintvalue) { return new PropertyValueUnion{ Type = PropertyValue.UintValue, Value = _uintvalue }; }
  public Fx.IntValueT AsIntValue() { return this.As<Fx.IntValueT>(); }
  public static PropertyValueUnion FromIntValue(Fx.IntValueT _intvalue) { return new PropertyValueUnion{ Type = PropertyValue.IntValue, Value = _intvalue }; }
  public Fx.FloatValueT AsFloatValue() { return this.As<Fx.FloatValueT>(); }
  public static PropertyValueUnion FromFloatValue(Fx.FloatValueT _floatvalue) { return new PropertyValueUnion{ Type = PropertyValue.FloatValue, Value = _floatvalue }; }
  public Fx.StringValueT AsStringValue() { return this.As<Fx.StringValueT>(); }
  public static PropertyValueUnion FromStringValue(Fx.StringValueT _stringvalue) { return new PropertyValueUnion{ Type = PropertyValue.StringValue, Value = _stringvalue }; }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, PropertyValueUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case PropertyValue.UintValue: return Fx.UintValue.Pack(builder, _o.AsUintValue()).Value;
      case PropertyValue.IntValue: return Fx.IntValue.Pack(builder, _o.AsIntValue()).Value;
      case PropertyValue.FloatValue: return Fx.FloatValue.Pack(builder, _o.AsFloatValue()).Value;
      case PropertyValue.StringValue: return Fx.StringValue.Pack(builder, _o.AsStringValue()).Value;
    }
  }
}

public enum ControlValue : byte
{
  NONE = 0,
  UintValue = 1,
  IntValue = 2,
  FloatValue = 3,
  Float2Value = 4,
  Float3Value = 5,
  Float4Value = 6,
  ColorValue = 7,
  TextureValue = 8,
  MeshValue = 9,
};

public class ControlValueUnion {
  public ControlValue Type { get; set; }
  public object Value { get; set; }

  public ControlValueUnion() {
    this.Type = ControlValue.NONE;
    this.Value = null;
  }

  public T As<T>() where T : class { return this.Value as T; }
  public Fx.UintValueT AsUintValue() { return this.As<Fx.UintValueT>(); }
  public static ControlValueUnion FromUintValue(Fx.UintValueT _uintvalue) { return new ControlValueUnion{ Type = ControlValue.UintValue, Value = _uintvalue }; }
  public Fx.IntValueT AsIntValue() { return this.As<Fx.IntValueT>(); }
  public static ControlValueUnion FromIntValue(Fx.IntValueT _intvalue) { return new ControlValueUnion{ Type = ControlValue.IntValue, Value = _intvalue }; }
  public Fx.FloatValueT AsFloatValue() { return this.As<Fx.FloatValueT>(); }
  public static ControlValueUnion FromFloatValue(Fx.FloatValueT _floatvalue) { return new ControlValueUnion{ Type = ControlValue.FloatValue, Value = _floatvalue }; }
  public Fx.Float2ValueT AsFloat2Value() { return this.As<Fx.Float2ValueT>(); }
  public static ControlValueUnion FromFloat2Value(Fx.Float2ValueT _float2value) { return new ControlValueUnion{ Type = ControlValue.Float2Value, Value = _float2value }; }
  public Fx.Float3ValueT AsFloat3Value() { return this.As<Fx.Float3ValueT>(); }
  public static ControlValueUnion FromFloat3Value(Fx.Float3ValueT _float3value) { return new ControlValueUnion{ Type = ControlValue.Float3Value, Value = _float3value }; }
  public Fx.Float4ValueT AsFloat4Value() { return this.As<Fx.Float4ValueT>(); }
  public static ControlValueUnion FromFloat4Value(Fx.Float4ValueT _float4value) { return new ControlValueUnion{ Type = ControlValue.Float4Value, Value = _float4value }; }
  public Fx.ColorValueT AsColorValue() { return this.As<Fx.ColorValueT>(); }
  public static ControlValueUnion FromColorValue(Fx.ColorValueT _colorvalue) { return new ControlValueUnion{ Type = ControlValue.ColorValue, Value = _colorvalue }; }
  public Fx.TextureValueT AsTextureValue() { return this.As<Fx.TextureValueT>(); }
  public static ControlValueUnion FromTextureValue(Fx.TextureValueT _texturevalue) { return new ControlValueUnion{ Type = ControlValue.TextureValue, Value = _texturevalue }; }
  public Fx.MeshValueT AsMeshValue() { return this.As<Fx.MeshValueT>(); }
  public static ControlValueUnion FromMeshValue(Fx.MeshValueT _meshvalue) { return new ControlValueUnion{ Type = ControlValue.MeshValue, Value = _meshvalue }; }

  public static int Pack(FlatBuffers.FlatBufferBuilder builder, ControlValueUnion _o) {
    switch (_o.Type) {
      default: return 0;
      case ControlValue.UintValue: return Fx.UintValue.Pack(builder, _o.AsUintValue()).Value;
      case ControlValue.IntValue: return Fx.IntValue.Pack(builder, _o.AsIntValue()).Value;
      case ControlValue.FloatValue: return Fx.FloatValue.Pack(builder, _o.AsFloatValue()).Value;
      case ControlValue.Float2Value: return Fx.Float2Value.Pack(builder, _o.AsFloat2Value()).Value;
      case ControlValue.Float3Value: return Fx.Float3Value.Pack(builder, _o.AsFloat3Value()).Value;
      case ControlValue.Float4Value: return Fx.Float4Value.Pack(builder, _o.AsFloat4Value()).Value;
      case ControlValue.ColorValue: return Fx.ColorValue.Pack(builder, _o.AsColorValue()).Value;
      case ControlValue.TextureValue: return Fx.TextureValue.Pack(builder, _o.AsTextureValue()).Value;
      case ControlValue.MeshValue: return Fx.MeshValue.Pack(builder, _o.AsMeshValue()).Value;
    }
  }
}

public struct BundleSignature : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static BundleSignature GetRootAsBundleSignature(ByteBuffer _bb) { return GetRootAsBundleSignature(_bb, new BundleSignature()); }
  public static BundleSignature GetRootAsBundleSignature(ByteBuffer _bb, BundleSignature obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BundleSignature __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Mode { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetModeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetModeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetModeArray() { return __p.__vector_as_array<byte>(4); }
  public string Version { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVersionBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetVersionBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetVersionArray() { return __p.__vector_as_array<byte>(6); }
  public string Commithash { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCommithashBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetCommithashBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetCommithashArray() { return __p.__vector_as_array<byte>(8); }
  public string Branch { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetBranchBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetBranchBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetBranchArray() { return __p.__vector_as_array<byte>(10); }
  public string Timestamp { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetTimestampBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetTimestampBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetTimestampArray() { return __p.__vector_as_array<byte>(12); }

  public static Offset<Fx.BundleSignature> CreateBundleSignature(FlatBufferBuilder builder,
      StringOffset modeOffset = default(StringOffset),
      StringOffset versionOffset = default(StringOffset),
      StringOffset commithashOffset = default(StringOffset),
      StringOffset branchOffset = default(StringOffset),
      StringOffset timestampOffset = default(StringOffset)) {
    builder.StartTable(5);
    BundleSignature.AddTimestamp(builder, timestampOffset);
    BundleSignature.AddBranch(builder, branchOffset);
    BundleSignature.AddCommithash(builder, commithashOffset);
    BundleSignature.AddVersion(builder, versionOffset);
    BundleSignature.AddMode(builder, modeOffset);
    return BundleSignature.EndBundleSignature(builder);
  }

  public static void StartBundleSignature(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddMode(FlatBufferBuilder builder, StringOffset modeOffset) { builder.AddOffset(0, modeOffset.Value, 0); }
  public static void AddVersion(FlatBufferBuilder builder, StringOffset versionOffset) { builder.AddOffset(1, versionOffset.Value, 0); }
  public static void AddCommithash(FlatBufferBuilder builder, StringOffset commithashOffset) { builder.AddOffset(2, commithashOffset.Value, 0); }
  public static void AddBranch(FlatBufferBuilder builder, StringOffset branchOffset) { builder.AddOffset(3, branchOffset.Value, 0); }
  public static void AddTimestamp(FlatBufferBuilder builder, StringOffset timestampOffset) { builder.AddOffset(4, timestampOffset.Value, 0); }
  public static Offset<Fx.BundleSignature> EndBundleSignature(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.BundleSignature>(o);
  }
  public BundleSignatureT UnPack() {
    var _o = new BundleSignatureT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BundleSignatureT _o) {
    _o.Mode = this.Mode;
    _o.Version = this.Version;
    _o.Commithash = this.Commithash;
    _o.Branch = this.Branch;
    _o.Timestamp = this.Timestamp;
  }
  public static Offset<Fx.BundleSignature> Pack(FlatBufferBuilder builder, BundleSignatureT _o) {
    if (_o == null) return default(Offset<Fx.BundleSignature>);
    var _mode = _o.Mode == null ? default(StringOffset) : builder.CreateString(_o.Mode);
    var _version = _o.Version == null ? default(StringOffset) : builder.CreateString(_o.Version);
    var _commithash = _o.Commithash == null ? default(StringOffset) : builder.CreateString(_o.Commithash);
    var _branch = _o.Branch == null ? default(StringOffset) : builder.CreateString(_o.Branch);
    var _timestamp = _o.Timestamp == null ? default(StringOffset) : builder.CreateString(_o.Timestamp);
    return CreateBundleSignature(
      builder,
      _mode,
      _version,
      _commithash,
      _branch,
      _timestamp);
  }
}

public class BundleSignatureT
{
  public string Mode { get; set; }
  public string Version { get; set; }
  public string Commithash { get; set; }
  public string Branch { get; set; }
  public string Timestamp { get; set; }

  public BundleSignatureT() {
    this.Mode = null;
    this.Version = null;
    this.Commithash = null;
    this.Branch = null;
    this.Timestamp = null;
  }
}

public struct BundleMeta : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static BundleMeta GetRootAsBundleMeta(ByteBuffer _bb) { return GetRootAsBundleMeta(_bb, new BundleMeta()); }
  public static BundleMeta GetRootAsBundleMeta(ByteBuffer _bb, BundleMeta obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BundleMeta __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Author { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetAuthorBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetAuthorBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetAuthorArray() { return __p.__vector_as_array<byte>(4); }
  public string Source { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetSourceBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetSourceBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetSourceArray() { return __p.__vector_as_array<byte>(6); }

  public static Offset<Fx.BundleMeta> CreateBundleMeta(FlatBufferBuilder builder,
      StringOffset authorOffset = default(StringOffset),
      StringOffset sourceOffset = default(StringOffset)) {
    builder.StartTable(2);
    BundleMeta.AddSource(builder, sourceOffset);
    BundleMeta.AddAuthor(builder, authorOffset);
    return BundleMeta.EndBundleMeta(builder);
  }

  public static void StartBundleMeta(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddAuthor(FlatBufferBuilder builder, StringOffset authorOffset) { builder.AddOffset(0, authorOffset.Value, 0); }
  public static void AddSource(FlatBufferBuilder builder, StringOffset sourceOffset) { builder.AddOffset(1, sourceOffset.Value, 0); }
  public static Offset<Fx.BundleMeta> EndBundleMeta(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.BundleMeta>(o);
  }
  public BundleMetaT UnPack() {
    var _o = new BundleMetaT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BundleMetaT _o) {
    _o.Author = this.Author;
    _o.Source = this.Source;
  }
  public static Offset<Fx.BundleMeta> Pack(FlatBufferBuilder builder, BundleMetaT _o) {
    if (_o == null) return default(Offset<Fx.BundleMeta>);
    var _author = _o.Author == null ? default(StringOffset) : builder.CreateString(_o.Author);
    var _source = _o.Source == null ? default(StringOffset) : builder.CreateString(_o.Source);
    return CreateBundleMeta(
      builder,
      _author,
      _source);
  }
}

public class BundleMetaT
{
  public string Author { get; set; }
  public string Source { get; set; }

  public BundleMetaT() {
    this.Author = null;
    this.Source = null;
  }
}

public struct UAVBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static UAVBundle GetRootAsUAVBundle(ByteBuffer _bb) { return GetRootAsUAVBundle(_bb, new UAVBundle()); }
  public static UAVBundle GetRootAsUAVBundle(ByteBuffer _bb, UAVBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UAVBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public uint Slot { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Stride { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public TypeLayout? Type { get { int o = __p.__offset(10); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<Fx.UAVBundle> CreateUAVBundle(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      uint slot = 0,
      uint stride = 0,
      Offset<TypeLayout> typeOffset = default(Offset<TypeLayout>)) {
    builder.StartTable(4);
    UAVBundle.AddType(builder, typeOffset);
    UAVBundle.AddStride(builder, stride);
    UAVBundle.AddSlot(builder, slot);
    UAVBundle.AddName(builder, nameOffset);
    return UAVBundle.EndUAVBundle(builder);
  }

  public static void StartUAVBundle(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddSlot(FlatBufferBuilder builder, uint slot) { builder.AddUint(1, slot, 0); }
  public static void AddStride(FlatBufferBuilder builder, uint stride) { builder.AddUint(2, stride, 0); }
  public static void AddType(FlatBufferBuilder builder, Offset<TypeLayout> typeOffset) { builder.AddOffset(3, typeOffset.Value, 0); }
  public static Offset<Fx.UAVBundle> EndUAVBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.UAVBundle>(o);
  }
  public UAVBundleT UnPack() {
    var _o = new UAVBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(UAVBundleT _o) {
    _o.Name = this.Name;
    _o.Slot = this.Slot;
    _o.Stride = this.Stride;
    _o.Type = this.Type.HasValue ? this.Type.Value.UnPack() : null;
  }
  public static Offset<Fx.UAVBundle> Pack(FlatBufferBuilder builder, UAVBundleT _o) {
    if (_o == null) return default(Offset<Fx.UAVBundle>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _type = _o.Type == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Type);
    return CreateUAVBundle(
      builder,
      _name,
      _o.Slot,
      _o.Stride,
      _type);
  }
}

public class UAVBundleT
{
  public string Name { get; set; }
  public uint Slot { get; set; }
  public uint Stride { get; set; }
  public TypeLayoutT Type { get; set; }

  public UAVBundleT() {
    this.Name = null;
    this.Slot = 0;
    this.Stride = 0;
    this.Type = null;
  }
}

public struct BufferBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static BufferBundle GetRootAsBufferBundle(ByteBuffer _bb) { return GetRootAsBufferBundle(_bb, new BufferBundle()); }
  public static BufferBundle GetRootAsBufferBundle(ByteBuffer _bb, BufferBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BufferBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public uint Slot { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Stride { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public TypeLayout? Type { get { int o = __p.__offset(10); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<Fx.BufferBundle> CreateBufferBundle(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      uint slot = 0,
      uint stride = 0,
      Offset<TypeLayout> typeOffset = default(Offset<TypeLayout>)) {
    builder.StartTable(4);
    BufferBundle.AddType(builder, typeOffset);
    BufferBundle.AddStride(builder, stride);
    BufferBundle.AddSlot(builder, slot);
    BufferBundle.AddName(builder, nameOffset);
    return BufferBundle.EndBufferBundle(builder);
  }

  public static void StartBufferBundle(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddSlot(FlatBufferBuilder builder, uint slot) { builder.AddUint(1, slot, 0); }
  public static void AddStride(FlatBufferBuilder builder, uint stride) { builder.AddUint(2, stride, 0); }
  public static void AddType(FlatBufferBuilder builder, Offset<TypeLayout> typeOffset) { builder.AddOffset(3, typeOffset.Value, 0); }
  public static Offset<Fx.BufferBundle> EndBufferBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.BufferBundle>(o);
  }
  public BufferBundleT UnPack() {
    var _o = new BufferBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BufferBundleT _o) {
    _o.Name = this.Name;
    _o.Slot = this.Slot;
    _o.Stride = this.Stride;
    _o.Type = this.Type.HasValue ? this.Type.Value.UnPack() : null;
  }
  public static Offset<Fx.BufferBundle> Pack(FlatBufferBuilder builder, BufferBundleT _o) {
    if (_o == null) return default(Offset<Fx.BufferBundle>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _type = _o.Type == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Type);
    return CreateBufferBundle(
      builder,
      _name,
      _o.Slot,
      _o.Stride,
      _type);
  }
}

public class BufferBundleT
{
  public string Name { get; set; }
  public uint Slot { get; set; }
  public uint Stride { get; set; }
  public TypeLayoutT Type { get; set; }

  public BufferBundleT() {
    this.Name = null;
    this.Slot = 0;
    this.Stride = 0;
    this.Type = null;
  }
}

public struct TextureBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static TextureBundle GetRootAsTextureBundle(ByteBuffer _bb) { return GetRootAsTextureBundle(_bb, new TextureBundle()); }
  public static TextureBundle GetRootAsTextureBundle(ByteBuffer _bb, TextureBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TextureBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public uint Slot { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Stride { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public TypeLayout? Type { get { int o = __p.__offset(10); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<Fx.TextureBundle> CreateTextureBundle(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      uint slot = 0,
      uint stride = 0,
      Offset<TypeLayout> typeOffset = default(Offset<TypeLayout>)) {
    builder.StartTable(4);
    TextureBundle.AddType(builder, typeOffset);
    TextureBundle.AddStride(builder, stride);
    TextureBundle.AddSlot(builder, slot);
    TextureBundle.AddName(builder, nameOffset);
    return TextureBundle.EndTextureBundle(builder);
  }

  public static void StartTextureBundle(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddSlot(FlatBufferBuilder builder, uint slot) { builder.AddUint(1, slot, 0); }
  public static void AddStride(FlatBufferBuilder builder, uint stride) { builder.AddUint(2, stride, 0); }
  public static void AddType(FlatBufferBuilder builder, Offset<TypeLayout> typeOffset) { builder.AddOffset(3, typeOffset.Value, 0); }
  public static Offset<Fx.TextureBundle> EndTextureBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.TextureBundle>(o);
  }
  public TextureBundleT UnPack() {
    var _o = new TextureBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TextureBundleT _o) {
    _o.Name = this.Name;
    _o.Slot = this.Slot;
    _o.Stride = this.Stride;
    _o.Type = this.Type.HasValue ? this.Type.Value.UnPack() : null;
  }
  public static Offset<Fx.TextureBundle> Pack(FlatBufferBuilder builder, TextureBundleT _o) {
    if (_o == null) return default(Offset<Fx.TextureBundle>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _type = _o.Type == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Type);
    return CreateTextureBundle(
      builder,
      _name,
      _o.Slot,
      _o.Stride,
      _type);
  }
}

public class TextureBundleT
{
  public string Name { get; set; }
  public uint Slot { get; set; }
  public uint Stride { get; set; }
  public TypeLayoutT Type { get; set; }

  public TextureBundleT() {
    this.Name = null;
    this.Slot = 0;
    this.Stride = 0;
    this.Type = null;
  }
}

public struct TrimeshBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static TrimeshBundle GetRootAsTrimeshBundle(ByteBuffer _bb) { return GetRootAsTrimeshBundle(_bb, new TrimeshBundle()); }
  public static TrimeshBundle GetRootAsTrimeshBundle(ByteBuffer _bb, TrimeshBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TrimeshBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public string VertexCountUName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVertexCountUNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetVertexCountUNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetVertexCountUNameArray() { return __p.__vector_as_array<byte>(6); }
  public string FaceCountUName { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFaceCountUNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetFaceCountUNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetFaceCountUNameArray() { return __p.__vector_as_array<byte>(8); }
  public string VerticesName { get { int o = __p.__offset(10); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVerticesNameBytes() { return __p.__vector_as_span<byte>(10, 1); }
#else
  public ArraySegment<byte>? GetVerticesNameBytes() { return __p.__vector_as_arraysegment(10); }
#endif
  public byte[] GetVerticesNameArray() { return __p.__vector_as_array<byte>(10); }
  public string FacesName { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFacesNameBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetFacesNameBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetFacesNameArray() { return __p.__vector_as_array<byte>(12); }
  public string GsAdjecencyName { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGsAdjecencyNameBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetGsAdjecencyNameBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetGsAdjecencyNameArray() { return __p.__vector_as_array<byte>(14); }
  public string FaceAdjacencyName { get { int o = __p.__offset(16); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetFaceAdjacencyNameBytes() { return __p.__vector_as_span<byte>(16, 1); }
#else
  public ArraySegment<byte>? GetFaceAdjacencyNameBytes() { return __p.__vector_as_arraysegment(16); }
#endif
  public byte[] GetFaceAdjacencyNameArray() { return __p.__vector_as_array<byte>(16); }

  public static Offset<Fx.TrimeshBundle> CreateTrimeshBundle(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset vertexCountUNameOffset = default(StringOffset),
      StringOffset faceCountUNameOffset = default(StringOffset),
      StringOffset verticesNameOffset = default(StringOffset),
      StringOffset facesNameOffset = default(StringOffset),
      StringOffset gsAdjecencyNameOffset = default(StringOffset),
      StringOffset faceAdjacencyNameOffset = default(StringOffset)) {
    builder.StartTable(7);
    TrimeshBundle.AddFaceAdjacencyName(builder, faceAdjacencyNameOffset);
    TrimeshBundle.AddGsAdjecencyName(builder, gsAdjecencyNameOffset);
    TrimeshBundle.AddFacesName(builder, facesNameOffset);
    TrimeshBundle.AddVerticesName(builder, verticesNameOffset);
    TrimeshBundle.AddFaceCountUName(builder, faceCountUNameOffset);
    TrimeshBundle.AddVertexCountUName(builder, vertexCountUNameOffset);
    TrimeshBundle.AddName(builder, nameOffset);
    return TrimeshBundle.EndTrimeshBundle(builder);
  }

  public static void StartTrimeshBundle(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddVertexCountUName(FlatBufferBuilder builder, StringOffset vertexCountUNameOffset) { builder.AddOffset(1, vertexCountUNameOffset.Value, 0); }
  public static void AddFaceCountUName(FlatBufferBuilder builder, StringOffset faceCountUNameOffset) { builder.AddOffset(2, faceCountUNameOffset.Value, 0); }
  public static void AddVerticesName(FlatBufferBuilder builder, StringOffset verticesNameOffset) { builder.AddOffset(3, verticesNameOffset.Value, 0); }
  public static void AddFacesName(FlatBufferBuilder builder, StringOffset facesNameOffset) { builder.AddOffset(4, facesNameOffset.Value, 0); }
  public static void AddGsAdjecencyName(FlatBufferBuilder builder, StringOffset gsAdjecencyNameOffset) { builder.AddOffset(5, gsAdjecencyNameOffset.Value, 0); }
  public static void AddFaceAdjacencyName(FlatBufferBuilder builder, StringOffset faceAdjacencyNameOffset) { builder.AddOffset(6, faceAdjacencyNameOffset.Value, 0); }
  public static Offset<Fx.TrimeshBundle> EndTrimeshBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.TrimeshBundle>(o);
  }
  public TrimeshBundleT UnPack() {
    var _o = new TrimeshBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TrimeshBundleT _o) {
    _o.Name = this.Name;
    _o.VertexCountUName = this.VertexCountUName;
    _o.FaceCountUName = this.FaceCountUName;
    _o.VerticesName = this.VerticesName;
    _o.FacesName = this.FacesName;
    _o.GsAdjecencyName = this.GsAdjecencyName;
    _o.FaceAdjacencyName = this.FaceAdjacencyName;
  }
  public static Offset<Fx.TrimeshBundle> Pack(FlatBufferBuilder builder, TrimeshBundleT _o) {
    if (_o == null) return default(Offset<Fx.TrimeshBundle>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _vertexCountUName = _o.VertexCountUName == null ? default(StringOffset) : builder.CreateString(_o.VertexCountUName);
    var _faceCountUName = _o.FaceCountUName == null ? default(StringOffset) : builder.CreateString(_o.FaceCountUName);
    var _verticesName = _o.VerticesName == null ? default(StringOffset) : builder.CreateString(_o.VerticesName);
    var _facesName = _o.FacesName == null ? default(StringOffset) : builder.CreateString(_o.FacesName);
    var _gsAdjecencyName = _o.GsAdjecencyName == null ? default(StringOffset) : builder.CreateString(_o.GsAdjecencyName);
    var _faceAdjacencyName = _o.FaceAdjacencyName == null ? default(StringOffset) : builder.CreateString(_o.FaceAdjacencyName);
    return CreateTrimeshBundle(
      builder,
      _name,
      _vertexCountUName,
      _faceCountUName,
      _verticesName,
      _facesName,
      _gsAdjecencyName,
      _faceAdjacencyName);
  }
}

public class TrimeshBundleT
{
  public string Name { get; set; }
  public string VertexCountUName { get; set; }
  public string FaceCountUName { get; set; }
  public string VerticesName { get; set; }
  public string FacesName { get; set; }
  public string GsAdjecencyName { get; set; }
  public string FaceAdjacencyName { get; set; }

  public TrimeshBundleT() {
    this.Name = null;
    this.VertexCountUName = null;
    this.FaceCountUName = null;
    this.VerticesName = null;
    this.FacesName = null;
    this.GsAdjecencyName = null;
    this.FaceAdjacencyName = null;
  }
}

public struct GLSLAttribute : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static GLSLAttribute GetRootAsGLSLAttribute(ByteBuffer _bb) { return GetRootAsGLSLAttribute(_bb, new GLSLAttribute()); }
  public static GLSLAttribute GetRootAsGLSLAttribute(ByteBuffer _bb, GLSLAttribute obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public GLSLAttribute __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Size { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Offset { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public string Name { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(8); }

  public static Offset<Fx.GLSLAttribute> CreateGLSLAttribute(FlatBufferBuilder builder,
      uint size = 0,
      uint offset = 0,
      StringOffset nameOffset = default(StringOffset)) {
    builder.StartTable(3);
    GLSLAttribute.AddName(builder, nameOffset);
    GLSLAttribute.AddOffset(builder, offset);
    GLSLAttribute.AddSize(builder, size);
    return GLSLAttribute.EndGLSLAttribute(builder);
  }

  public static void StartGLSLAttribute(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddSize(FlatBufferBuilder builder, uint size) { builder.AddUint(0, size, 0); }
  public static void AddOffset(FlatBufferBuilder builder, uint offset) { builder.AddUint(1, offset, 0); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(2, nameOffset.Value, 0); }
  public static Offset<Fx.GLSLAttribute> EndGLSLAttribute(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.GLSLAttribute>(o);
  }
  public GLSLAttributeT UnPack() {
    var _o = new GLSLAttributeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(GLSLAttributeT _o) {
    _o.Size = this.Size;
    _o.Offset = this.Offset;
    _o.Name = this.Name;
  }
  public static Offset<Fx.GLSLAttribute> Pack(FlatBufferBuilder builder, GLSLAttributeT _o) {
    if (_o == null) return default(Offset<Fx.GLSLAttribute>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    return CreateGLSLAttribute(
      builder,
      _o.Size,
      _o.Offset,
      _name);
  }
}

public class GLSLAttributeT
{
  public uint Size { get; set; }
  public uint Offset { get; set; }
  public string Name { get; set; }

  public GLSLAttributeT() {
    this.Size = 0;
    this.Offset = 0;
    this.Name = null;
  }
}

public struct RoutineBytecodeBundleResources : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RoutineBytecodeBundleResources GetRootAsRoutineBytecodeBundleResources(ByteBuffer _bb) { return GetRootAsRoutineBytecodeBundleResources(_bb, new RoutineBytecodeBundleResources()); }
  public static RoutineBytecodeBundleResources GetRootAsRoutineBytecodeBundleResources(ByteBuffer _bb, RoutineBytecodeBundleResources obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutineBytecodeBundleResources __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.UAVBundle? Uavs(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.UAVBundle?)(new Fx.UAVBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int UavsLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Fx.BufferBundle? Buffers(int j) { int o = __p.__offset(6); return o != 0 ? (Fx.BufferBundle?)(new Fx.BufferBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int BuffersLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Fx.TextureBundle? Textures(int j) { int o = __p.__offset(8); return o != 0 ? (Fx.TextureBundle?)(new Fx.TextureBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TexturesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Fx.TrimeshBundle? Trimeshes(int j) { int o = __p.__offset(10); return o != 0 ? (Fx.TrimeshBundle?)(new Fx.TrimeshBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int TrimeshesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(FlatBufferBuilder builder,
      VectorOffset uavsOffset = default(VectorOffset),
      VectorOffset buffersOffset = default(VectorOffset),
      VectorOffset texturesOffset = default(VectorOffset),
      VectorOffset trimeshesOffset = default(VectorOffset)) {
    builder.StartTable(4);
    RoutineBytecodeBundleResources.AddTrimeshes(builder, trimeshesOffset);
    RoutineBytecodeBundleResources.AddTextures(builder, texturesOffset);
    RoutineBytecodeBundleResources.AddBuffers(builder, buffersOffset);
    RoutineBytecodeBundleResources.AddUavs(builder, uavsOffset);
    return RoutineBytecodeBundleResources.EndRoutineBytecodeBundleResources(builder);
  }

  public static void StartRoutineBytecodeBundleResources(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddUavs(FlatBufferBuilder builder, VectorOffset uavsOffset) { builder.AddOffset(0, uavsOffset.Value, 0); }
  public static VectorOffset CreateUavsVector(FlatBufferBuilder builder, Offset<Fx.UAVBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateUavsVectorBlock(FlatBufferBuilder builder, Offset<Fx.UAVBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateUavsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.UAVBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateUavsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.UAVBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartUavsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddBuffers(FlatBufferBuilder builder, VectorOffset buffersOffset) { builder.AddOffset(1, buffersOffset.Value, 0); }
  public static VectorOffset CreateBuffersVector(FlatBufferBuilder builder, Offset<Fx.BufferBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, Offset<Fx.BufferBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.BufferBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateBuffersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.BufferBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartBuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTextures(FlatBufferBuilder builder, VectorOffset texturesOffset) { builder.AddOffset(2, texturesOffset.Value, 0); }
  public static VectorOffset CreateTexturesVector(FlatBufferBuilder builder, Offset<Fx.TextureBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, Offset<Fx.TextureBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.TextureBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTexturesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.TextureBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTexturesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddTrimeshes(FlatBufferBuilder builder, VectorOffset trimeshesOffset) { builder.AddOffset(3, trimeshesOffset.Value, 0); }
  public static VectorOffset CreateTrimeshesVector(FlatBufferBuilder builder, Offset<Fx.TrimeshBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateTrimeshesVectorBlock(FlatBufferBuilder builder, Offset<Fx.TrimeshBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTrimeshesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.TrimeshBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateTrimeshesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.TrimeshBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartTrimeshesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.RoutineBytecodeBundleResources> EndRoutineBytecodeBundleResources(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RoutineBytecodeBundleResources>(o);
  }
  public RoutineBytecodeBundleResourcesT UnPack() {
    var _o = new RoutineBytecodeBundleResourcesT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutineBytecodeBundleResourcesT _o) {
    _o.Uavs = new List<Fx.UAVBundleT>();
    for (var _j = 0; _j < this.UavsLength; ++_j) {_o.Uavs.Add(this.Uavs(_j).HasValue ? this.Uavs(_j).Value.UnPack() : null);}
    _o.Buffers = new List<Fx.BufferBundleT>();
    for (var _j = 0; _j < this.BuffersLength; ++_j) {_o.Buffers.Add(this.Buffers(_j).HasValue ? this.Buffers(_j).Value.UnPack() : null);}
    _o.Textures = new List<Fx.TextureBundleT>();
    for (var _j = 0; _j < this.TexturesLength; ++_j) {_o.Textures.Add(this.Textures(_j).HasValue ? this.Textures(_j).Value.UnPack() : null);}
    _o.Trimeshes = new List<Fx.TrimeshBundleT>();
    for (var _j = 0; _j < this.TrimeshesLength; ++_j) {_o.Trimeshes.Add(this.Trimeshes(_j).HasValue ? this.Trimeshes(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.RoutineBytecodeBundleResources> Pack(FlatBufferBuilder builder, RoutineBytecodeBundleResourcesT _o) {
    if (_o == null) return default(Offset<Fx.RoutineBytecodeBundleResources>);
    var _uavs = default(VectorOffset);
    if (_o.Uavs != null) {
      var __uavs = new Offset<Fx.UAVBundle>[_o.Uavs.Count];
      for (var _j = 0; _j < __uavs.Length; ++_j) { __uavs[_j] = Fx.UAVBundle.Pack(builder, _o.Uavs[_j]); }
      _uavs = CreateUavsVector(builder, __uavs);
    }
    var _buffers = default(VectorOffset);
    if (_o.Buffers != null) {
      var __buffers = new Offset<Fx.BufferBundle>[_o.Buffers.Count];
      for (var _j = 0; _j < __buffers.Length; ++_j) { __buffers[_j] = Fx.BufferBundle.Pack(builder, _o.Buffers[_j]); }
      _buffers = CreateBuffersVector(builder, __buffers);
    }
    var _textures = default(VectorOffset);
    if (_o.Textures != null) {
      var __textures = new Offset<Fx.TextureBundle>[_o.Textures.Count];
      for (var _j = 0; _j < __textures.Length; ++_j) { __textures[_j] = Fx.TextureBundle.Pack(builder, _o.Textures[_j]); }
      _textures = CreateTexturesVector(builder, __textures);
    }
    var _trimeshes = default(VectorOffset);
    if (_o.Trimeshes != null) {
      var __trimeshes = new Offset<Fx.TrimeshBundle>[_o.Trimeshes.Count];
      for (var _j = 0; _j < __trimeshes.Length; ++_j) { __trimeshes[_j] = Fx.TrimeshBundle.Pack(builder, _o.Trimeshes[_j]); }
      _trimeshes = CreateTrimeshesVector(builder, __trimeshes);
    }
    return CreateRoutineBytecodeBundleResources(
      builder,
      _uavs,
      _buffers,
      _textures,
      _trimeshes);
  }
}

public class RoutineBytecodeBundleResourcesT
{
  public List<Fx.UAVBundleT> Uavs { get; set; }
  public List<Fx.BufferBundleT> Buffers { get; set; }
  public List<Fx.TextureBundleT> Textures { get; set; }
  public List<Fx.TrimeshBundleT> Trimeshes { get; set; }

  public RoutineBytecodeBundleResourcesT() {
    this.Uavs = null;
    this.Buffers = null;
    this.Textures = null;
    this.Trimeshes = null;
  }
}

public struct RoutineBytecodeBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RoutineBytecodeBundle GetRootAsRoutineBytecodeBundle(ByteBuffer _bb) { return GetRootAsRoutineBytecodeBundle(_bb, new RoutineBytecodeBundle()); }
  public static RoutineBytecodeBundle GetRootAsRoutineBytecodeBundle(ByteBuffer _bb, RoutineBytecodeBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutineBytecodeBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte Code(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CodeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCodeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCodeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCodeArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.RoutineBytecodeBundleResources? Resources { get { int o = __p.__offset(6); return o != 0 ? (Fx.RoutineBytecodeBundleResources?)(new Fx.RoutineBytecodeBundleResources()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public uint Numthreads(int j) { int o = __p.__offset(8); return o != 0 ? __p.bb.GetUint(__p.__vector(o) + j * 4) : (uint)0; }
  public int NumthreadsLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<uint> GetNumthreadsBytes() { return __p.__vector_as_span<uint>(8, 4); }
#else
  public ArraySegment<byte>? GetNumthreadsBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public uint[] GetNumthreadsArray() { return __p.__vector_as_array<uint>(8); }

  public static Offset<Fx.RoutineBytecodeBundle> CreateRoutineBytecodeBundle(FlatBufferBuilder builder,
      VectorOffset codeOffset = default(VectorOffset),
      Offset<Fx.RoutineBytecodeBundleResources> resourcesOffset = default(Offset<Fx.RoutineBytecodeBundleResources>),
      VectorOffset numthreadsOffset = default(VectorOffset)) {
    builder.StartTable(3);
    RoutineBytecodeBundle.AddNumthreads(builder, numthreadsOffset);
    RoutineBytecodeBundle.AddResources(builder, resourcesOffset);
    RoutineBytecodeBundle.AddCode(builder, codeOffset);
    return RoutineBytecodeBundle.EndRoutineBytecodeBundle(builder);
  }

  public static void StartRoutineBytecodeBundle(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddCode(FlatBufferBuilder builder, VectorOffset codeOffset) { builder.AddOffset(0, codeOffset.Value, 0); }
  public static VectorOffset CreateCodeVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCodeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddResources(FlatBufferBuilder builder, Offset<Fx.RoutineBytecodeBundleResources> resourcesOffset) { builder.AddOffset(1, resourcesOffset.Value, 0); }
  public static void AddNumthreads(FlatBufferBuilder builder, VectorOffset numthreadsOffset) { builder.AddOffset(2, numthreadsOffset.Value, 0); }
  public static VectorOffset CreateNumthreadsVector(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddUint(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateNumthreadsVectorBlock(FlatBufferBuilder builder, uint[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNumthreadsVectorBlock(FlatBufferBuilder builder, ArraySegment<uint> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateNumthreadsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<uint>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartNumthreadsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.RoutineBytecodeBundle> EndRoutineBytecodeBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RoutineBytecodeBundle>(o);
  }
  public RoutineBytecodeBundleT UnPack() {
    var _o = new RoutineBytecodeBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutineBytecodeBundleT _o) {
    _o.Code = new List<byte>();
    for (var _j = 0; _j < this.CodeLength; ++_j) {_o.Code.Add(this.Code(_j));}
    _o.Resources = this.Resources.HasValue ? this.Resources.Value.UnPack() : null;
    _o.Numthreads = new List<uint>();
    for (var _j = 0; _j < this.NumthreadsLength; ++_j) {_o.Numthreads.Add(this.Numthreads(_j));}
  }
  public static Offset<Fx.RoutineBytecodeBundle> Pack(FlatBufferBuilder builder, RoutineBytecodeBundleT _o) {
    if (_o == null) return default(Offset<Fx.RoutineBytecodeBundle>);
    var _code = default(VectorOffset);
    if (_o.Code != null) {
      var __code = _o.Code.ToArray();
      _code = CreateCodeVector(builder, __code);
    }
    var _resources = _o.Resources == null ? default(Offset<Fx.RoutineBytecodeBundleResources>) : Fx.RoutineBytecodeBundleResources.Pack(builder, _o.Resources);
    var _numthreads = default(VectorOffset);
    if (_o.Numthreads != null) {
      var __numthreads = _o.Numthreads.ToArray();
      _numthreads = CreateNumthreadsVector(builder, __numthreads);
    }
    return CreateRoutineBytecodeBundle(
      builder,
      _code,
      _resources,
      _numthreads);
  }
}

public class RoutineBytecodeBundleT
{
  public List<byte> Code { get; set; }
  public Fx.RoutineBytecodeBundleResourcesT Resources { get; set; }
  public List<uint> Numthreads { get; set; }

  public RoutineBytecodeBundleT() {
    this.Code = null;
    this.Resources = null;
    this.Numthreads = null;
  }
}

public struct Pass11BytecodeBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static Pass11BytecodeBundle GetRootAsPass11BytecodeBundle(ByteBuffer _bb) { return GetRootAsPass11BytecodeBundle(_bb, new Pass11BytecodeBundle()); }
  public static Pass11BytecodeBundle GetRootAsPass11BytecodeBundle(ByteBuffer _bb, Pass11BytecodeBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Pass11BytecodeBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte Code(int j) { int o = __p.__offset(4); return o != 0 ? __p.bb.Get(__p.__vector(o) + j * 1) : (byte)0; }
  public int CodeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCodeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCodeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCodeArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Fx.Pass11BytecodeBundle> CreatePass11BytecodeBundle(FlatBufferBuilder builder,
      VectorOffset codeOffset = default(VectorOffset)) {
    builder.StartTable(1);
    Pass11BytecodeBundle.AddCode(builder, codeOffset);
    return Pass11BytecodeBundle.EndPass11BytecodeBundle(builder);
  }

  public static void StartPass11BytecodeBundle(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddCode(FlatBufferBuilder builder, VectorOffset codeOffset) { builder.AddOffset(0, codeOffset.Value, 0); }
  public static VectorOffset CreateCodeVector(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, byte[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, ArraySegment<byte> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCodeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<byte>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCodeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static Offset<Fx.Pass11BytecodeBundle> EndPass11BytecodeBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.Pass11BytecodeBundle>(o);
  }
  public Pass11BytecodeBundleT UnPack() {
    var _o = new Pass11BytecodeBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Pass11BytecodeBundleT _o) {
    _o.Code = new List<byte>();
    for (var _j = 0; _j < this.CodeLength; ++_j) {_o.Code.Add(this.Code(_j));}
  }
  public static Offset<Fx.Pass11BytecodeBundle> Pack(FlatBufferBuilder builder, Pass11BytecodeBundleT _o) {
    if (_o == null) return default(Offset<Fx.Pass11BytecodeBundle>);
    var _code = default(VectorOffset);
    if (_o.Code != null) {
      var __code = _o.Code.ToArray();
      _code = CreateCodeVector(builder, __code);
    }
    return CreatePass11BytecodeBundle(
      builder,
      _code);
  }
}

public class Pass11BytecodeBundleT
{
  public List<byte> Code { get; set; }

  public Pass11BytecodeBundleT() {
    this.Code = null;
  }
}

public struct RoutineGLSLSourceBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RoutineGLSLSourceBundle GetRootAsRoutineGLSLSourceBundle(ByteBuffer _bb) { return GetRootAsRoutineGLSLSourceBundle(_bb, new RoutineGLSLSourceBundle()); }
  public static RoutineGLSLSourceBundle GetRootAsRoutineGLSLSourceBundle(ByteBuffer _bb, RoutineGLSLSourceBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutineGLSLSourceBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Code { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCodeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCodeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCodeArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.GLSLAttribute? Attributes(int j) { int o = __p.__offset(6); return o != 0 ? (Fx.GLSLAttribute?)(new Fx.GLSLAttribute()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int AttributesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public CBBundle? Cbuffers(int j) { int o = __p.__offset(8); return o != 0 ? (CBBundle?)(new CBBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CbuffersLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.RoutineGLSLSourceBundle> CreateRoutineGLSLSourceBundle(FlatBufferBuilder builder,
      StringOffset codeOffset = default(StringOffset),
      VectorOffset attributesOffset = default(VectorOffset),
      VectorOffset cbuffersOffset = default(VectorOffset)) {
    builder.StartTable(3);
    RoutineGLSLSourceBundle.AddCbuffers(builder, cbuffersOffset);
    RoutineGLSLSourceBundle.AddAttributes(builder, attributesOffset);
    RoutineGLSLSourceBundle.AddCode(builder, codeOffset);
    return RoutineGLSLSourceBundle.EndRoutineGLSLSourceBundle(builder);
  }

  public static void StartRoutineGLSLSourceBundle(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddCode(FlatBufferBuilder builder, StringOffset codeOffset) { builder.AddOffset(0, codeOffset.Value, 0); }
  public static void AddAttributes(FlatBufferBuilder builder, VectorOffset attributesOffset) { builder.AddOffset(1, attributesOffset.Value, 0); }
  public static VectorOffset CreateAttributesVector(FlatBufferBuilder builder, Offset<Fx.GLSLAttribute>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateAttributesVectorBlock(FlatBufferBuilder builder, Offset<Fx.GLSLAttribute>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAttributesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.GLSLAttribute>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateAttributesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.GLSLAttribute>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartAttributesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddCbuffers(FlatBufferBuilder builder, VectorOffset cbuffersOffset) { builder.AddOffset(2, cbuffersOffset.Value, 0); }
  public static VectorOffset CreateCbuffersVector(FlatBufferBuilder builder, Offset<CBBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, Offset<CBBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<CBBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<CBBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCbuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.RoutineGLSLSourceBundle> EndRoutineGLSLSourceBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RoutineGLSLSourceBundle>(o);
  }
  public RoutineGLSLSourceBundleT UnPack() {
    var _o = new RoutineGLSLSourceBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutineGLSLSourceBundleT _o) {
    _o.Code = this.Code;
    _o.Attributes = new List<Fx.GLSLAttributeT>();
    for (var _j = 0; _j < this.AttributesLength; ++_j) {_o.Attributes.Add(this.Attributes(_j).HasValue ? this.Attributes(_j).Value.UnPack() : null);}
    _o.Cbuffers = new List<CBBundleT>();
    for (var _j = 0; _j < this.CbuffersLength; ++_j) {_o.Cbuffers.Add(this.Cbuffers(_j).HasValue ? this.Cbuffers(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.RoutineGLSLSourceBundle> Pack(FlatBufferBuilder builder, RoutineGLSLSourceBundleT _o) {
    if (_o == null) return default(Offset<Fx.RoutineGLSLSourceBundle>);
    var _code = _o.Code == null ? default(StringOffset) : builder.CreateString(_o.Code);
    var _attributes = default(VectorOffset);
    if (_o.Attributes != null) {
      var __attributes = new Offset<Fx.GLSLAttribute>[_o.Attributes.Count];
      for (var _j = 0; _j < __attributes.Length; ++_j) { __attributes[_j] = Fx.GLSLAttribute.Pack(builder, _o.Attributes[_j]); }
      _attributes = CreateAttributesVector(builder, __attributes);
    }
    var _cbuffers = default(VectorOffset);
    if (_o.Cbuffers != null) {
      var __cbuffers = new Offset<CBBundle>[_o.Cbuffers.Count];
      for (var _j = 0; _j < __cbuffers.Length; ++_j) { __cbuffers[_j] = CBBundle.Pack(builder, _o.Cbuffers[_j]); }
      _cbuffers = CreateCbuffersVector(builder, __cbuffers);
    }
    return CreateRoutineGLSLSourceBundle(
      builder,
      _code,
      _attributes,
      _cbuffers);
  }
}

public class RoutineGLSLSourceBundleT
{
  public string Code { get; set; }
  public List<Fx.GLSLAttributeT> Attributes { get; set; }
  public List<CBBundleT> Cbuffers { get; set; }

  public RoutineGLSLSourceBundleT() {
    this.Code = null;
    this.Attributes = null;
    this.Cbuffers = null;
  }
}

public struct RoutineHLSLSourceBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RoutineHLSLSourceBundle GetRootAsRoutineHLSLSourceBundle(ByteBuffer _bb) { return GetRootAsRoutineHLSLSourceBundle(_bb, new RoutineHLSLSourceBundle()); }
  public static RoutineHLSLSourceBundle GetRootAsRoutineHLSLSourceBundle(ByteBuffer _bb, RoutineHLSLSourceBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutineHLSLSourceBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Code { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetCodeBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetCodeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetCodeArray() { return __p.__vector_as_array<byte>(4); }
  public string EntryName { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetEntryNameBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetEntryNameBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetEntryNameArray() { return __p.__vector_as_array<byte>(6); }
  public CBBundle? Cbuffers(int j) { int o = __p.__offset(8); return o != 0 ? (CBBundle?)(new CBBundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int CbuffersLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.RoutineHLSLSourceBundle> CreateRoutineHLSLSourceBundle(FlatBufferBuilder builder,
      StringOffset codeOffset = default(StringOffset),
      StringOffset entryNameOffset = default(StringOffset),
      VectorOffset cbuffersOffset = default(VectorOffset)) {
    builder.StartTable(3);
    RoutineHLSLSourceBundle.AddCbuffers(builder, cbuffersOffset);
    RoutineHLSLSourceBundle.AddEntryName(builder, entryNameOffset);
    RoutineHLSLSourceBundle.AddCode(builder, codeOffset);
    return RoutineHLSLSourceBundle.EndRoutineHLSLSourceBundle(builder);
  }

  public static void StartRoutineHLSLSourceBundle(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddCode(FlatBufferBuilder builder, StringOffset codeOffset) { builder.AddOffset(0, codeOffset.Value, 0); }
  public static void AddEntryName(FlatBufferBuilder builder, StringOffset entryNameOffset) { builder.AddOffset(1, entryNameOffset.Value, 0); }
  public static void AddCbuffers(FlatBufferBuilder builder, VectorOffset cbuffersOffset) { builder.AddOffset(2, cbuffersOffset.Value, 0); }
  public static VectorOffset CreateCbuffersVector(FlatBufferBuilder builder, Offset<CBBundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, Offset<CBBundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<CBBundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateCbuffersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<CBBundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartCbuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.RoutineHLSLSourceBundle> EndRoutineHLSLSourceBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RoutineHLSLSourceBundle>(o);
  }
  public RoutineHLSLSourceBundleT UnPack() {
    var _o = new RoutineHLSLSourceBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutineHLSLSourceBundleT _o) {
    _o.Code = this.Code;
    _o.EntryName = this.EntryName;
    _o.Cbuffers = new List<CBBundleT>();
    for (var _j = 0; _j < this.CbuffersLength; ++_j) {_o.Cbuffers.Add(this.Cbuffers(_j).HasValue ? this.Cbuffers(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.RoutineHLSLSourceBundle> Pack(FlatBufferBuilder builder, RoutineHLSLSourceBundleT _o) {
    if (_o == null) return default(Offset<Fx.RoutineHLSLSourceBundle>);
    var _code = _o.Code == null ? default(StringOffset) : builder.CreateString(_o.Code);
    var _entryName = _o.EntryName == null ? default(StringOffset) : builder.CreateString(_o.EntryName);
    var _cbuffers = default(VectorOffset);
    if (_o.Cbuffers != null) {
      var __cbuffers = new Offset<CBBundle>[_o.Cbuffers.Count];
      for (var _j = 0; _j < __cbuffers.Length; ++_j) { __cbuffers[_j] = CBBundle.Pack(builder, _o.Cbuffers[_j]); }
      _cbuffers = CreateCbuffersVector(builder, __cbuffers);
    }
    return CreateRoutineHLSLSourceBundle(
      builder,
      _code,
      _entryName,
      _cbuffers);
  }
}

public class RoutineHLSLSourceBundleT
{
  public string Code { get; set; }
  public string EntryName { get; set; }
  public List<CBBundleT> Cbuffers { get; set; }

  public RoutineHLSLSourceBundleT() {
    this.Code = null;
    this.EntryName = null;
    this.Cbuffers = null;
  }
}

public struct RoutineShaderBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RoutineShaderBundle GetRootAsRoutineShaderBundle(ByteBuffer _bb) { return GetRootAsRoutineShaderBundle(_bb, new RoutineShaderBundle()); }
  public static RoutineShaderBundle GetRootAsRoutineShaderBundle(ByteBuffer _bb, RoutineShaderBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RoutineShaderBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.RoutineSourceBundle ShadersType(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.RoutineSourceBundle)__p.bb.Get(__p.__vector(o) + j * 1) : (Fx.RoutineSourceBundle)0; }
  public int ShadersTypeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Fx.RoutineSourceBundle> GetShadersTypeBytes() { return __p.__vector_as_span<Fx.RoutineSourceBundle>(4, 1); }
#else
  public ArraySegment<byte>? GetShadersTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public Fx.RoutineSourceBundle[] GetShadersTypeArray() { int o = __p.__offset(4); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Fx.RoutineSourceBundle[] a = new Fx.RoutineSourceBundle[l]; for (int i = 0; i < l; i++) { a[i] = (Fx.RoutineSourceBundle)__p.bb.Get(p + i * 1); } return a; }
  public TTable? Shaders<TTable>(int j) where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(__p.__vector(o) + j * 4) : null; }
  public int ShadersLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.RoutineShaderBundle> CreateRoutineShaderBundle(FlatBufferBuilder builder,
      VectorOffset shaders_typeOffset = default(VectorOffset),
      VectorOffset shadersOffset = default(VectorOffset)) {
    builder.StartTable(2);
    RoutineShaderBundle.AddShaders(builder, shadersOffset);
    RoutineShaderBundle.AddShadersType(builder, shaders_typeOffset);
    return RoutineShaderBundle.EndRoutineShaderBundle(builder);
  }

  public static void StartRoutineShaderBundle(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddShadersType(FlatBufferBuilder builder, VectorOffset shadersTypeOffset) { builder.AddOffset(0, shadersTypeOffset.Value, 0); }
  public static VectorOffset CreateShadersTypeVector(FlatBufferBuilder builder, Fx.RoutineSourceBundle[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte((byte)data[i]); return builder.EndVector(); }
  public static VectorOffset CreateShadersTypeVectorBlock(FlatBufferBuilder builder, Fx.RoutineSourceBundle[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShadersTypeVectorBlock(FlatBufferBuilder builder, ArraySegment<Fx.RoutineSourceBundle> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShadersTypeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Fx.RoutineSourceBundle>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShadersTypeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddShaders(FlatBufferBuilder builder, VectorOffset shadersOffset) { builder.AddOffset(1, shadersOffset.Value, 0); }
  public static VectorOffset CreateShadersVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateShadersVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShadersVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateShadersVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartShadersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.RoutineShaderBundle> EndRoutineShaderBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RoutineShaderBundle>(o);
  }
  public RoutineShaderBundleT UnPack() {
    var _o = new RoutineShaderBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RoutineShaderBundleT _o) {
    _o.Shaders = new List<Fx.RoutineSourceBundleUnion>();
    for (var _j = 0; _j < this.ShadersLength; ++_j) {
      var _o_Shaders = new Fx.RoutineSourceBundleUnion();
      _o_Shaders.Type = this.ShadersType(_j);
      switch (this.ShadersType(_j)) {
        default: break;
        case Fx.RoutineSourceBundle.RoutineGLSLSourceBundle:
          _o_Shaders.Value = this.Shaders<Fx.RoutineGLSLSourceBundle>(_j).HasValue ? this.Shaders<Fx.RoutineGLSLSourceBundle>(_j).Value.UnPack() : null;
          break;
        case Fx.RoutineSourceBundle.RoutineHLSLSourceBundle:
          _o_Shaders.Value = this.Shaders<Fx.RoutineHLSLSourceBundle>(_j).HasValue ? this.Shaders<Fx.RoutineHLSLSourceBundle>(_j).Value.UnPack() : null;
          break;
      }
      _o.Shaders.Add(_o_Shaders);
    }
  }
  public static Offset<Fx.RoutineShaderBundle> Pack(FlatBufferBuilder builder, RoutineShaderBundleT _o) {
    if (_o == null) return default(Offset<Fx.RoutineShaderBundle>);
    var _shaders_type = default(VectorOffset);
    if (_o.Shaders != null) {
      var __shaders_type = new Fx.RoutineSourceBundle[_o.Shaders.Count];
      for (var _j = 0; _j < __shaders_type.Length; ++_j) { __shaders_type[_j] = _o.Shaders[_j].Type; }
      _shaders_type = CreateShadersTypeVector(builder, __shaders_type);
    }
    var _shaders = default(VectorOffset);
    if (_o.Shaders != null) {
      var __shaders = new int[_o.Shaders.Count];
      for (var _j = 0; _j < __shaders.Length; ++_j) { __shaders[_j] = Fx.RoutineSourceBundleUnion.Pack(builder,  _o.Shaders[_j]); }
      _shaders = CreateShadersVector(builder, __shaders);
    }
    return CreateRoutineShaderBundle(
      builder,
      _shaders_type,
      _shaders);
  }
}

public class RoutineShaderBundleT
{
  public List<Fx.RoutineSourceBundleUnion> Shaders { get; set; }

  public RoutineShaderBundleT() {
    this.Shaders = null;
  }
}

public struct PartRenderPass : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static PartRenderPass GetRootAsPartRenderPass(ByteBuffer _bb) { return GetRootAsPartRenderPass(_bb, new PartRenderPass()); }
  public static PartRenderPass GetRootAsPartRenderPass(ByteBuffer _bb, PartRenderPass obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PartRenderPass __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.RoutineBundle RoutinesType(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.RoutineBundle)__p.bb.Get(__p.__vector(o) + j * 1) : (Fx.RoutineBundle)0; }
  public int RoutinesTypeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Fx.RoutineBundle> GetRoutinesTypeBytes() { return __p.__vector_as_span<Fx.RoutineBundle>(4, 1); }
#else
  public ArraySegment<byte>? GetRoutinesTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public Fx.RoutineBundle[] GetRoutinesTypeArray() { int o = __p.__offset(4); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Fx.RoutineBundle[] a = new Fx.RoutineBundle[l]; for (int i = 0; i < l; i++) { a[i] = (Fx.RoutineBundle)__p.bb.Get(p + i * 1); } return a; }
  public TTable? Routines<TTable>(int j) where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(__p.__vector(o) + j * 4) : null; }
  public int RoutinesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public string Geometry { get { int o = __p.__offset(8); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetGeometryBytes() { return __p.__vector_as_span<byte>(8, 1); }
#else
  public ArraySegment<byte>? GetGeometryBytes() { return __p.__vector_as_arraysegment(8); }
#endif
  public byte[] GetGeometryArray() { return __p.__vector_as_array<byte>(8); }
  public bool Sorting { get { int o = __p.__offset(10); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public uint InstanceCount { get { int o = __p.__offset(12); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Stride { get { int o = __p.__offset(14); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public TypeLayout? Instance { get { int o = __p.__offset(16); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Fx.RenderState? RenderStates(int j) { int o = __p.__offset(18); return o != 0 ? (Fx.RenderState?)(new Fx.RenderState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderStatesLength { get { int o = __p.__offset(18); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.PartRenderPass> CreatePartRenderPass(FlatBufferBuilder builder,
      VectorOffset routines_typeOffset = default(VectorOffset),
      VectorOffset routinesOffset = default(VectorOffset),
      StringOffset geometryOffset = default(StringOffset),
      bool sorting = false,
      uint instanceCount = 0,
      uint stride = 0,
      Offset<TypeLayout> instanceOffset = default(Offset<TypeLayout>),
      VectorOffset renderStatesOffset = default(VectorOffset)) {
    builder.StartTable(8);
    PartRenderPass.AddRenderStates(builder, renderStatesOffset);
    PartRenderPass.AddInstance(builder, instanceOffset);
    PartRenderPass.AddStride(builder, stride);
    PartRenderPass.AddInstanceCount(builder, instanceCount);
    PartRenderPass.AddGeometry(builder, geometryOffset);
    PartRenderPass.AddRoutines(builder, routinesOffset);
    PartRenderPass.AddRoutinesType(builder, routines_typeOffset);
    PartRenderPass.AddSorting(builder, sorting);
    return PartRenderPass.EndPartRenderPass(builder);
  }

  public static void StartPartRenderPass(FlatBufferBuilder builder) { builder.StartTable(8); }
  public static void AddRoutinesType(FlatBufferBuilder builder, VectorOffset routinesTypeOffset) { builder.AddOffset(0, routinesTypeOffset.Value, 0); }
  public static VectorOffset CreateRoutinesTypeVector(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte((byte)data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, ArraySegment<Fx.RoutineBundle> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Fx.RoutineBundle>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRoutinesTypeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddRoutines(FlatBufferBuilder builder, VectorOffset routinesOffset) { builder.AddOffset(1, routinesOffset.Value, 0); }
  public static VectorOffset CreateRoutinesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRoutinesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddGeometry(FlatBufferBuilder builder, StringOffset geometryOffset) { builder.AddOffset(2, geometryOffset.Value, 0); }
  public static void AddSorting(FlatBufferBuilder builder, bool sorting) { builder.AddBool(3, sorting, false); }
  public static void AddInstanceCount(FlatBufferBuilder builder, uint instanceCount) { builder.AddUint(4, instanceCount, 0); }
  public static void AddStride(FlatBufferBuilder builder, uint stride) { builder.AddUint(5, stride, 0); }
  public static void AddInstance(FlatBufferBuilder builder, Offset<TypeLayout> instanceOffset) { builder.AddOffset(6, instanceOffset.Value, 0); }
  public static void AddRenderStates(FlatBufferBuilder builder, VectorOffset renderStatesOffset) { builder.AddOffset(7, renderStatesOffset.Value, 0); }
  public static VectorOffset CreateRenderStatesVector(FlatBufferBuilder builder, Offset<Fx.RenderState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, Offset<Fx.RenderState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.RenderState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.RenderState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.PartRenderPass> EndPartRenderPass(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.PartRenderPass>(o);
  }
  public PartRenderPassT UnPack() {
    var _o = new PartRenderPassT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PartRenderPassT _o) {
    _o.Routines = new List<Fx.RoutineBundleUnion>();
    for (var _j = 0; _j < this.RoutinesLength; ++_j) {
      var _o_Routines = new Fx.RoutineBundleUnion();
      _o_Routines.Type = this.RoutinesType(_j);
      switch (this.RoutinesType(_j)) {
        default: break;
        case Fx.RoutineBundle.RoutineBytecodeBundle:
          _o_Routines.Value = this.Routines<Fx.RoutineBytecodeBundle>(_j).HasValue ? this.Routines<Fx.RoutineBytecodeBundle>(_j).Value.UnPack() : null;
          break;
        case Fx.RoutineBundle.RoutineShaderBundle:
          _o_Routines.Value = this.Routines<Fx.RoutineShaderBundle>(_j).HasValue ? this.Routines<Fx.RoutineShaderBundle>(_j).Value.UnPack() : null;
          break;
      }
      _o.Routines.Add(_o_Routines);
    }
    _o.Geometry = this.Geometry;
    _o.Sorting = this.Sorting;
    _o.InstanceCount = this.InstanceCount;
    _o.Stride = this.Stride;
    _o.Instance = this.Instance.HasValue ? this.Instance.Value.UnPack() : null;
    _o.RenderStates = new List<Fx.RenderStateT>();
    for (var _j = 0; _j < this.RenderStatesLength; ++_j) {_o.RenderStates.Add(this.RenderStates(_j).HasValue ? this.RenderStates(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.PartRenderPass> Pack(FlatBufferBuilder builder, PartRenderPassT _o) {
    if (_o == null) return default(Offset<Fx.PartRenderPass>);
    var _routines_type = default(VectorOffset);
    if (_o.Routines != null) {
      var __routines_type = new Fx.RoutineBundle[_o.Routines.Count];
      for (var _j = 0; _j < __routines_type.Length; ++_j) { __routines_type[_j] = _o.Routines[_j].Type; }
      _routines_type = CreateRoutinesTypeVector(builder, __routines_type);
    }
    var _routines = default(VectorOffset);
    if (_o.Routines != null) {
      var __routines = new int[_o.Routines.Count];
      for (var _j = 0; _j < __routines.Length; ++_j) { __routines[_j] = Fx.RoutineBundleUnion.Pack(builder,  _o.Routines[_j]); }
      _routines = CreateRoutinesVector(builder, __routines);
    }
    var _geometry = _o.Geometry == null ? default(StringOffset) : builder.CreateString(_o.Geometry);
    var _instance = _o.Instance == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Instance);
    var _renderStates = default(VectorOffset);
    if (_o.RenderStates != null) {
      var __renderStates = new Offset<Fx.RenderState>[_o.RenderStates.Count];
      for (var _j = 0; _j < __renderStates.Length; ++_j) { __renderStates[_j] = Fx.RenderState.Pack(builder, _o.RenderStates[_j]); }
      _renderStates = CreateRenderStatesVector(builder, __renderStates);
    }
    return CreatePartRenderPass(
      builder,
      _routines_type,
      _routines,
      _geometry,
      _o.Sorting,
      _o.InstanceCount,
      _o.Stride,
      _instance,
      _renderStates);
  }
}

public class PartRenderPassT
{
  public List<Fx.RoutineBundleUnion> Routines { get; set; }
  public string Geometry { get; set; }
  public bool Sorting { get; set; }
  public uint InstanceCount { get; set; }
  public uint Stride { get; set; }
  public TypeLayoutT Instance { get; set; }
  public List<Fx.RenderStateT> RenderStates { get; set; }

  public PartRenderPassT() {
    this.Routines = null;
    this.Geometry = null;
    this.Sorting = false;
    this.InstanceCount = 0;
    this.Stride = 0;
    this.Instance = null;
    this.RenderStates = null;
  }
}

public struct PartBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static PartBundle GetRootAsPartBundle(ByteBuffer _bb) { return GetRootAsPartBundle(_bb, new PartBundle()); }
  public static PartBundle GetRootAsPartBundle(ByteBuffer _bb, PartBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PartBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Capacity { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public Fx.RoutineBundle SimulationRoutinesType(int j) { int o = __p.__offset(6); return o != 0 ? (Fx.RoutineBundle)__p.bb.Get(__p.__vector(o) + j * 1) : (Fx.RoutineBundle)0; }
  public int SimulationRoutinesTypeLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Fx.RoutineBundle> GetSimulationRoutinesTypeBytes() { return __p.__vector_as_span<Fx.RoutineBundle>(6, 1); }
#else
  public ArraySegment<byte>? GetSimulationRoutinesTypeBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public Fx.RoutineBundle[] GetSimulationRoutinesTypeArray() { int o = __p.__offset(6); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Fx.RoutineBundle[] a = new Fx.RoutineBundle[l]; for (int i = 0; i < l; i++) { a[i] = (Fx.RoutineBundle)__p.bb.Get(p + i * 1); } return a; }
  public TTable? SimulationRoutines<TTable>(int j) where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(__p.__vector(o) + j * 4) : null; }
  public int SimulationRoutinesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Fx.PartRenderPass? RenderPasses(int j) { int o = __p.__offset(10); return o != 0 ? (Fx.PartRenderPass?)(new Fx.PartRenderPass()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderPassesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
  public TypeLayout? Particle { get { int o = __p.__offset(12); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }

  public static Offset<Fx.PartBundle> CreatePartBundle(FlatBufferBuilder builder,
      uint capacity = 0,
      VectorOffset simulationRoutines_typeOffset = default(VectorOffset),
      VectorOffset simulationRoutinesOffset = default(VectorOffset),
      VectorOffset renderPassesOffset = default(VectorOffset),
      Offset<TypeLayout> particleOffset = default(Offset<TypeLayout>)) {
    builder.StartTable(5);
    PartBundle.AddParticle(builder, particleOffset);
    PartBundle.AddRenderPasses(builder, renderPassesOffset);
    PartBundle.AddSimulationRoutines(builder, simulationRoutinesOffset);
    PartBundle.AddSimulationRoutinesType(builder, simulationRoutines_typeOffset);
    PartBundle.AddCapacity(builder, capacity);
    return PartBundle.EndPartBundle(builder);
  }

  public static void StartPartBundle(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddCapacity(FlatBufferBuilder builder, uint capacity) { builder.AddUint(0, capacity, 0); }
  public static void AddSimulationRoutinesType(FlatBufferBuilder builder, VectorOffset simulationRoutinesTypeOffset) { builder.AddOffset(1, simulationRoutinesTypeOffset.Value, 0); }
  public static VectorOffset CreateSimulationRoutinesTypeVector(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte((byte)data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesTypeVectorBlock(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesTypeVectorBlock(FlatBufferBuilder builder, ArraySegment<Fx.RoutineBundle> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesTypeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Fx.RoutineBundle>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSimulationRoutinesTypeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddSimulationRoutines(FlatBufferBuilder builder, VectorOffset simulationRoutinesOffset) { builder.AddOffset(2, simulationRoutinesOffset.Value, 0); }
  public static VectorOffset CreateSimulationRoutinesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateSimulationRoutinesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartSimulationRoutinesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddRenderPasses(FlatBufferBuilder builder, VectorOffset renderPassesOffset) { builder.AddOffset(3, renderPassesOffset.Value, 0); }
  public static VectorOffset CreateRenderPassesVector(FlatBufferBuilder builder, Offset<Fx.PartRenderPass>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, Offset<Fx.PartRenderPass>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.PartRenderPass>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.PartRenderPass>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderPassesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddParticle(FlatBufferBuilder builder, Offset<TypeLayout> particleOffset) { builder.AddOffset(4, particleOffset.Value, 0); }
  public static Offset<Fx.PartBundle> EndPartBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.PartBundle>(o);
  }
  public PartBundleT UnPack() {
    var _o = new PartBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PartBundleT _o) {
    _o.Capacity = this.Capacity;
    _o.SimulationRoutines = new List<Fx.RoutineBundleUnion>();
    for (var _j = 0; _j < this.SimulationRoutinesLength; ++_j) {
      var _o_SimulationRoutines = new Fx.RoutineBundleUnion();
      _o_SimulationRoutines.Type = this.SimulationRoutinesType(_j);
      switch (this.SimulationRoutinesType(_j)) {
        default: break;
        case Fx.RoutineBundle.RoutineBytecodeBundle:
          _o_SimulationRoutines.Value = this.SimulationRoutines<Fx.RoutineBytecodeBundle>(_j).HasValue ? this.SimulationRoutines<Fx.RoutineBytecodeBundle>(_j).Value.UnPack() : null;
          break;
        case Fx.RoutineBundle.RoutineShaderBundle:
          _o_SimulationRoutines.Value = this.SimulationRoutines<Fx.RoutineShaderBundle>(_j).HasValue ? this.SimulationRoutines<Fx.RoutineShaderBundle>(_j).Value.UnPack() : null;
          break;
      }
      _o.SimulationRoutines.Add(_o_SimulationRoutines);
    }
    _o.RenderPasses = new List<Fx.PartRenderPassT>();
    for (var _j = 0; _j < this.RenderPassesLength; ++_j) {_o.RenderPasses.Add(this.RenderPasses(_j).HasValue ? this.RenderPasses(_j).Value.UnPack() : null);}
    _o.Particle = this.Particle.HasValue ? this.Particle.Value.UnPack() : null;
  }
  public static Offset<Fx.PartBundle> Pack(FlatBufferBuilder builder, PartBundleT _o) {
    if (_o == null) return default(Offset<Fx.PartBundle>);
    var _simulationRoutines_type = default(VectorOffset);
    if (_o.SimulationRoutines != null) {
      var __simulationRoutines_type = new Fx.RoutineBundle[_o.SimulationRoutines.Count];
      for (var _j = 0; _j < __simulationRoutines_type.Length; ++_j) { __simulationRoutines_type[_j] = _o.SimulationRoutines[_j].Type; }
      _simulationRoutines_type = CreateSimulationRoutinesTypeVector(builder, __simulationRoutines_type);
    }
    var _simulationRoutines = default(VectorOffset);
    if (_o.SimulationRoutines != null) {
      var __simulationRoutines = new int[_o.SimulationRoutines.Count];
      for (var _j = 0; _j < __simulationRoutines.Length; ++_j) { __simulationRoutines[_j] = Fx.RoutineBundleUnion.Pack(builder,  _o.SimulationRoutines[_j]); }
      _simulationRoutines = CreateSimulationRoutinesVector(builder, __simulationRoutines);
    }
    var _renderPasses = default(VectorOffset);
    if (_o.RenderPasses != null) {
      var __renderPasses = new Offset<Fx.PartRenderPass>[_o.RenderPasses.Count];
      for (var _j = 0; _j < __renderPasses.Length; ++_j) { __renderPasses[_j] = Fx.PartRenderPass.Pack(builder, _o.RenderPasses[_j]); }
      _renderPasses = CreateRenderPassesVector(builder, __renderPasses);
    }
    var _particle = _o.Particle == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Particle);
    return CreatePartBundle(
      builder,
      _o.Capacity,
      _simulationRoutines_type,
      _simulationRoutines,
      _renderPasses,
      _particle);
  }
}

public class PartBundleT
{
  public uint Capacity { get; set; }
  public List<Fx.RoutineBundleUnion> SimulationRoutines { get; set; }
  public List<Fx.PartRenderPassT> RenderPasses { get; set; }
  public TypeLayoutT Particle { get; set; }

  public PartBundleT() {
    this.Capacity = 0;
    this.SimulationRoutines = null;
    this.RenderPasses = null;
    this.Particle = null;
  }
}

public struct RenderState : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static RenderState GetRootAsRenderState(ByteBuffer _bb) { return GetRootAsRenderState(_bb, new RenderState()); }
  public static RenderState GetRootAsRenderState(ByteBuffer _bb, RenderState obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public RenderState __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Type { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public uint Value { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }

  public static Offset<Fx.RenderState> CreateRenderState(FlatBufferBuilder builder,
      uint type = 0,
      uint value = 0) {
    builder.StartTable(2);
    RenderState.AddValue(builder, value);
    RenderState.AddType(builder, type);
    return RenderState.EndRenderState(builder);
  }

  public static void StartRenderState(FlatBufferBuilder builder) { builder.StartTable(2); }
  public static void AddType(FlatBufferBuilder builder, uint type) { builder.AddUint(0, type, 0); }
  public static void AddValue(FlatBufferBuilder builder, uint value) { builder.AddUint(1, value, 0); }
  public static Offset<Fx.RenderState> EndRenderState(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.RenderState>(o);
  }
  public RenderStateT UnPack() {
    var _o = new RenderStateT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(RenderStateT _o) {
    _o.Type = this.Type;
    _o.Value = this.Value;
  }
  public static Offset<Fx.RenderState> Pack(FlatBufferBuilder builder, RenderStateT _o) {
    if (_o == null) return default(Offset<Fx.RenderState>);
    return CreateRenderState(
      builder,
      _o.Type,
      _o.Value);
  }
}

public class RenderStateT
{
  public uint Type { get; set; }
  public uint Value { get; set; }

  public RenderStateT() {
    this.Type = 0;
    this.Value = 0;
  }
}

public struct MatRenderPass : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static MatRenderPass GetRootAsMatRenderPass(ByteBuffer _bb) { return GetRootAsMatRenderPass(_bb, new MatRenderPass()); }
  public static MatRenderPass GetRootAsMatRenderPass(ByteBuffer _bb, MatRenderPass obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatRenderPass __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.RoutineBundle RoutinesType(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.RoutineBundle)__p.bb.Get(__p.__vector(o) + j * 1) : (Fx.RoutineBundle)0; }
  public int RoutinesTypeLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<Fx.RoutineBundle> GetRoutinesTypeBytes() { return __p.__vector_as_span<Fx.RoutineBundle>(4, 1); }
#else
  public ArraySegment<byte>? GetRoutinesTypeBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public Fx.RoutineBundle[] GetRoutinesTypeArray() { int o = __p.__offset(4); if (o == 0) return null; int p = __p.__vector(o); int l = __p.__vector_len(o); Fx.RoutineBundle[] a = new Fx.RoutineBundle[l]; for (int i = 0; i < l; i++) { a[i] = (Fx.RoutineBundle)__p.bb.Get(p + i * 1); } return a; }
  public TTable? Routines<TTable>(int j) where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(__p.__vector(o) + j * 4) : null; }
  public int RoutinesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
  public TypeLayout? Instance { get { int o = __p.__offset(8); return o != 0 ? (TypeLayout?)(new TypeLayout()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public uint Stride { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetUint(o + __p.bb_pos) : (uint)0; } }
  public Fx.RenderState? RenderStates(int j) { int o = __p.__offset(12); return o != 0 ? (Fx.RenderState?)(new Fx.RenderState()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderStatesLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.MatRenderPass> CreateMatRenderPass(FlatBufferBuilder builder,
      VectorOffset routines_typeOffset = default(VectorOffset),
      VectorOffset routinesOffset = default(VectorOffset),
      Offset<TypeLayout> instanceOffset = default(Offset<TypeLayout>),
      uint stride = 0,
      VectorOffset renderStatesOffset = default(VectorOffset)) {
    builder.StartTable(5);
    MatRenderPass.AddRenderStates(builder, renderStatesOffset);
    MatRenderPass.AddStride(builder, stride);
    MatRenderPass.AddInstance(builder, instanceOffset);
    MatRenderPass.AddRoutines(builder, routinesOffset);
    MatRenderPass.AddRoutinesType(builder, routines_typeOffset);
    return MatRenderPass.EndMatRenderPass(builder);
  }

  public static void StartMatRenderPass(FlatBufferBuilder builder) { builder.StartTable(5); }
  public static void AddRoutinesType(FlatBufferBuilder builder, VectorOffset routinesTypeOffset) { builder.AddOffset(0, routinesTypeOffset.Value, 0); }
  public static VectorOffset CreateRoutinesTypeVector(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); for (int i = data.Length - 1; i >= 0; i--) builder.AddByte((byte)data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, Fx.RoutineBundle[] data) { builder.StartVector(1, data.Length, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, ArraySegment<Fx.RoutineBundle> data) { builder.StartVector(1, data.Count, 1); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesTypeVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Fx.RoutineBundle>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRoutinesTypeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(1, numElems, 1); }
  public static void AddRoutines(FlatBufferBuilder builder, VectorOffset routinesOffset) { builder.AddOffset(1, routinesOffset.Value, 0); }
  public static VectorOffset CreateRoutinesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRoutinesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRoutinesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddInstance(FlatBufferBuilder builder, Offset<TypeLayout> instanceOffset) { builder.AddOffset(2, instanceOffset.Value, 0); }
  public static void AddStride(FlatBufferBuilder builder, uint stride) { builder.AddUint(3, stride, 0); }
  public static void AddRenderStates(FlatBufferBuilder builder, VectorOffset renderStatesOffset) { builder.AddOffset(4, renderStatesOffset.Value, 0); }
  public static VectorOffset CreateRenderStatesVector(FlatBufferBuilder builder, Offset<Fx.RenderState>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, Offset<Fx.RenderState>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.RenderState>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderStatesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.RenderState>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderStatesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.MatRenderPass> EndMatRenderPass(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.MatRenderPass>(o);
  }
  public MatRenderPassT UnPack() {
    var _o = new MatRenderPassT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MatRenderPassT _o) {
    _o.Routines = new List<Fx.RoutineBundleUnion>();
    for (var _j = 0; _j < this.RoutinesLength; ++_j) {
      var _o_Routines = new Fx.RoutineBundleUnion();
      _o_Routines.Type = this.RoutinesType(_j);
      switch (this.RoutinesType(_j)) {
        default: break;
        case Fx.RoutineBundle.RoutineBytecodeBundle:
          _o_Routines.Value = this.Routines<Fx.RoutineBytecodeBundle>(_j).HasValue ? this.Routines<Fx.RoutineBytecodeBundle>(_j).Value.UnPack() : null;
          break;
        case Fx.RoutineBundle.RoutineShaderBundle:
          _o_Routines.Value = this.Routines<Fx.RoutineShaderBundle>(_j).HasValue ? this.Routines<Fx.RoutineShaderBundle>(_j).Value.UnPack() : null;
          break;
      }
      _o.Routines.Add(_o_Routines);
    }
    _o.Instance = this.Instance.HasValue ? this.Instance.Value.UnPack() : null;
    _o.Stride = this.Stride;
    _o.RenderStates = new List<Fx.RenderStateT>();
    for (var _j = 0; _j < this.RenderStatesLength; ++_j) {_o.RenderStates.Add(this.RenderStates(_j).HasValue ? this.RenderStates(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.MatRenderPass> Pack(FlatBufferBuilder builder, MatRenderPassT _o) {
    if (_o == null) return default(Offset<Fx.MatRenderPass>);
    var _routines_type = default(VectorOffset);
    if (_o.Routines != null) {
      var __routines_type = new Fx.RoutineBundle[_o.Routines.Count];
      for (var _j = 0; _j < __routines_type.Length; ++_j) { __routines_type[_j] = _o.Routines[_j].Type; }
      _routines_type = CreateRoutinesTypeVector(builder, __routines_type);
    }
    var _routines = default(VectorOffset);
    if (_o.Routines != null) {
      var __routines = new int[_o.Routines.Count];
      for (var _j = 0; _j < __routines.Length; ++_j) { __routines[_j] = Fx.RoutineBundleUnion.Pack(builder,  _o.Routines[_j]); }
      _routines = CreateRoutinesVector(builder, __routines);
    }
    var _instance = _o.Instance == null ? default(Offset<TypeLayout>) : TypeLayout.Pack(builder, _o.Instance);
    var _renderStates = default(VectorOffset);
    if (_o.RenderStates != null) {
      var __renderStates = new Offset<Fx.RenderState>[_o.RenderStates.Count];
      for (var _j = 0; _j < __renderStates.Length; ++_j) { __renderStates[_j] = Fx.RenderState.Pack(builder, _o.RenderStates[_j]); }
      _renderStates = CreateRenderStatesVector(builder, __renderStates);
    }
    return CreateMatRenderPass(
      builder,
      _routines_type,
      _routines,
      _instance,
      _o.Stride,
      _renderStates);
  }
}

public class MatRenderPassT
{
  public List<Fx.RoutineBundleUnion> Routines { get; set; }
  public TypeLayoutT Instance { get; set; }
  public uint Stride { get; set; }
  public List<Fx.RenderStateT> RenderStates { get; set; }

  public MatRenderPassT() {
    this.Routines = null;
    this.Instance = null;
    this.Stride = 0;
    this.RenderStates = null;
  }
}

public struct MatBundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static MatBundle GetRootAsMatBundle(ByteBuffer _bb) { return GetRootAsMatBundle(_bb, new MatBundle()); }
  public static MatBundle GetRootAsMatBundle(ByteBuffer _bb, MatBundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MatBundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.MatRenderPass? RenderPasses(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.MatRenderPass?)(new Fx.MatRenderPass()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int RenderPassesLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.MatBundle> CreateMatBundle(FlatBufferBuilder builder,
      VectorOffset renderPassesOffset = default(VectorOffset)) {
    builder.StartTable(1);
    MatBundle.AddRenderPasses(builder, renderPassesOffset);
    return MatBundle.EndMatBundle(builder);
  }

  public static void StartMatBundle(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddRenderPasses(FlatBufferBuilder builder, VectorOffset renderPassesOffset) { builder.AddOffset(0, renderPassesOffset.Value, 0); }
  public static VectorOffset CreateRenderPassesVector(FlatBufferBuilder builder, Offset<Fx.MatRenderPass>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, Offset<Fx.MatRenderPass>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.MatRenderPass>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateRenderPassesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.MatRenderPass>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartRenderPassesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.MatBundle> EndMatBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.MatBundle>(o);
  }
  public MatBundleT UnPack() {
    var _o = new MatBundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MatBundleT _o) {
    _o.RenderPasses = new List<Fx.MatRenderPassT>();
    for (var _j = 0; _j < this.RenderPassesLength; ++_j) {_o.RenderPasses.Add(this.RenderPasses(_j).HasValue ? this.RenderPasses(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.MatBundle> Pack(FlatBufferBuilder builder, MatBundleT _o) {
    if (_o == null) return default(Offset<Fx.MatBundle>);
    var _renderPasses = default(VectorOffset);
    if (_o.RenderPasses != null) {
      var __renderPasses = new Offset<Fx.MatRenderPass>[_o.RenderPasses.Count];
      for (var _j = 0; _j < __renderPasses.Length; ++_j) { __renderPasses[_j] = Fx.MatRenderPass.Pack(builder, _o.RenderPasses[_j]); }
      _renderPasses = CreateRenderPassesVector(builder, __renderPasses);
    }
    return CreateMatBundle(
      builder,
      _renderPasses);
  }
}

public class MatBundleT
{
  public List<Fx.MatRenderPassT> RenderPasses { get; set; }

  public MatBundleT() {
    this.RenderPasses = null;
  }
}

public struct StringValue : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static StringValue GetRootAsStringValue(ByteBuffer _bb) { return GetRootAsStringValue(_bb, new StringValue()); }
  public static StringValue GetRootAsStringValue(ByteBuffer _bb, StringValue obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public StringValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Value { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetValueBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetValueBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetValueArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Fx.StringValue> CreateStringValue(FlatBufferBuilder builder,
      StringOffset valueOffset = default(StringOffset)) {
    builder.StartTable(1);
    StringValue.AddValue(builder, valueOffset);
    return StringValue.EndStringValue(builder);
  }

  public static void StartStringValue(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValue(FlatBufferBuilder builder, StringOffset valueOffset) { builder.AddOffset(0, valueOffset.Value, 0); }
  public static Offset<Fx.StringValue> EndStringValue(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.StringValue>(o);
  }
  public StringValueT UnPack() {
    var _o = new StringValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(StringValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.StringValue> Pack(FlatBufferBuilder builder, StringValueT _o) {
    if (_o == null) return default(Offset<Fx.StringValue>);
    var _value = _o.Value == null ? default(StringOffset) : builder.CreateString(_o.Value);
    return CreateStringValue(
      builder,
      _value);
  }
}

public class StringValueT
{
  public string Value { get; set; }

  public StringValueT() {
    this.Value = null;
  }
}

public struct TextureValue : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static TextureValue GetRootAsTextureValue(ByteBuffer _bb) { return GetRootAsTextureValue(_bb, new TextureValue()); }
  public static TextureValue GetRootAsTextureValue(ByteBuffer _bb, TextureValue obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public TextureValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Value { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetValueBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetValueBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetValueArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Fx.TextureValue> CreateTextureValue(FlatBufferBuilder builder,
      StringOffset valueOffset = default(StringOffset)) {
    builder.StartTable(1);
    TextureValue.AddValue(builder, valueOffset);
    return TextureValue.EndTextureValue(builder);
  }

  public static void StartTextureValue(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValue(FlatBufferBuilder builder, StringOffset valueOffset) { builder.AddOffset(0, valueOffset.Value, 0); }
  public static Offset<Fx.TextureValue> EndTextureValue(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.TextureValue>(o);
  }
  public TextureValueT UnPack() {
    var _o = new TextureValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(TextureValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.TextureValue> Pack(FlatBufferBuilder builder, TextureValueT _o) {
    if (_o == null) return default(Offset<Fx.TextureValue>);
    var _value = _o.Value == null ? default(StringOffset) : builder.CreateString(_o.Value);
    return CreateTextureValue(
      builder,
      _value);
  }
}

public class TextureValueT
{
  public string Value { get; set; }

  public TextureValueT() {
    this.Value = null;
  }
}

public struct MeshValue : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static MeshValue GetRootAsMeshValue(ByteBuffer _bb) { return GetRootAsMeshValue(_bb, new MeshValue()); }
  public static MeshValue GetRootAsMeshValue(ByteBuffer _bb, MeshValue obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public MeshValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Value { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetValueBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetValueBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetValueArray() { return __p.__vector_as_array<byte>(4); }

  public static Offset<Fx.MeshValue> CreateMeshValue(FlatBufferBuilder builder,
      StringOffset valueOffset = default(StringOffset)) {
    builder.StartTable(1);
    MeshValue.AddValue(builder, valueOffset);
    return MeshValue.EndMeshValue(builder);
  }

  public static void StartMeshValue(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddValue(FlatBufferBuilder builder, StringOffset valueOffset) { builder.AddOffset(0, valueOffset.Value, 0); }
  public static Offset<Fx.MeshValue> EndMeshValue(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.MeshValue>(o);
  }
  public MeshValueT UnPack() {
    var _o = new MeshValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(MeshValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.MeshValue> Pack(FlatBufferBuilder builder, MeshValueT _o) {
    if (_o == null) return default(Offset<Fx.MeshValue>);
    var _value = _o.Value == null ? default(StringOffset) : builder.CreateString(_o.Value);
    return CreateMeshValue(
      builder,
      _value);
  }
}

public class MeshValueT
{
  public string Value { get; set; }

  public MeshValueT() {
    this.Value = null;
  }
}

public struct UintValue : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public UintValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public uint Value { get { return __p.bb.GetUint(__p.bb_pos + 0); } }

  public static Offset<Fx.UintValue> CreateUintValue(FlatBufferBuilder builder, uint Value) {
    builder.Prep(4, 4);
    builder.PutUint(Value);
    return new Offset<Fx.UintValue>(builder.Offset);
  }
  public UintValueT UnPack() {
    var _o = new UintValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(UintValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.UintValue> Pack(FlatBufferBuilder builder, UintValueT _o) {
    if (_o == null) return default(Offset<Fx.UintValue>);
    return CreateUintValue(
      builder,
      _o.Value);
  }
}

public class UintValueT
{
  public uint Value { get; set; }

  public UintValueT() {
    this.Value = 0;
  }
}

public struct IntValue : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public IntValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Value { get { return __p.bb.GetInt(__p.bb_pos + 0); } }

  public static Offset<Fx.IntValue> CreateIntValue(FlatBufferBuilder builder, int Value) {
    builder.Prep(4, 4);
    builder.PutInt(Value);
    return new Offset<Fx.IntValue>(builder.Offset);
  }
  public IntValueT UnPack() {
    var _o = new IntValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(IntValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.IntValue> Pack(FlatBufferBuilder builder, IntValueT _o) {
    if (_o == null) return default(Offset<Fx.IntValue>);
    return CreateIntValue(
      builder,
      _o.Value);
  }
}

public class IntValueT
{
  public int Value { get; set; }

  public IntValueT() {
    this.Value = 0;
  }
}

public struct FloatValue : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public FloatValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float Value { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }

  public static Offset<Fx.FloatValue> CreateFloatValue(FlatBufferBuilder builder, float Value) {
    builder.Prep(4, 4);
    builder.PutFloat(Value);
    return new Offset<Fx.FloatValue>(builder.Offset);
  }
  public FloatValueT UnPack() {
    var _o = new FloatValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(FloatValueT _o) {
    _o.Value = this.Value;
  }
  public static Offset<Fx.FloatValue> Pack(FlatBufferBuilder builder, FloatValueT _o) {
    if (_o == null) return default(Offset<Fx.FloatValue>);
    return CreateFloatValue(
      builder,
      _o.Value);
  }
}

public class FloatValueT
{
  public float Value { get; set; }

  public FloatValueT() {
    this.Value = 0.0f;
  }
}

public struct Float2Value : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Float2Value __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }

  public static Offset<Fx.Float2Value> CreateFloat2Value(FlatBufferBuilder builder, float X, float Y) {
    builder.Prep(4, 8);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<Fx.Float2Value>(builder.Offset);
  }
  public Float2ValueT UnPack() {
    var _o = new Float2ValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Float2ValueT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
  }
  public static Offset<Fx.Float2Value> Pack(FlatBufferBuilder builder, Float2ValueT _o) {
    if (_o == null) return default(Offset<Fx.Float2Value>);
    return CreateFloat2Value(
      builder,
      _o.X,
      _o.Y);
  }
}

public class Float2ValueT
{
  public float X { get; set; }
  public float Y { get; set; }

  public Float2ValueT() {
    this.X = 0.0f;
    this.Y = 0.0f;
  }
}

public struct Float3Value : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Float3Value __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }

  public static Offset<Fx.Float3Value> CreateFloat3Value(FlatBufferBuilder builder, float X, float Y, float Z) {
    builder.Prep(4, 12);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<Fx.Float3Value>(builder.Offset);
  }
  public Float3ValueT UnPack() {
    var _o = new Float3ValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Float3ValueT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
  }
  public static Offset<Fx.Float3Value> Pack(FlatBufferBuilder builder, Float3ValueT _o) {
    if (_o == null) return default(Offset<Fx.Float3Value>);
    return CreateFloat3Value(
      builder,
      _o.X,
      _o.Y,
      _o.Z);
  }
}

public class Float3ValueT
{
  public float X { get; set; }
  public float Y { get; set; }
  public float Z { get; set; }

  public Float3ValueT() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
  }
}

public struct Float4Value : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public Float4Value __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public float X { get { return __p.bb.GetFloat(__p.bb_pos + 0); } }
  public float Y { get { return __p.bb.GetFloat(__p.bb_pos + 4); } }
  public float Z { get { return __p.bb.GetFloat(__p.bb_pos + 8); } }
  public float W { get { return __p.bb.GetFloat(__p.bb_pos + 12); } }

  public static Offset<Fx.Float4Value> CreateFloat4Value(FlatBufferBuilder builder, float X, float Y, float Z, float W) {
    builder.Prep(4, 16);
    builder.PutFloat(W);
    builder.PutFloat(Z);
    builder.PutFloat(Y);
    builder.PutFloat(X);
    return new Offset<Fx.Float4Value>(builder.Offset);
  }
  public Float4ValueT UnPack() {
    var _o = new Float4ValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(Float4ValueT _o) {
    _o.X = this.X;
    _o.Y = this.Y;
    _o.Z = this.Z;
    _o.W = this.W;
  }
  public static Offset<Fx.Float4Value> Pack(FlatBufferBuilder builder, Float4ValueT _o) {
    if (_o == null) return default(Offset<Fx.Float4Value>);
    return CreateFloat4Value(
      builder,
      _o.X,
      _o.Y,
      _o.Z,
      _o.W);
  }
}

public class Float4ValueT
{
  public float X { get; set; }
  public float Y { get; set; }
  public float Z { get; set; }
  public float W { get; set; }

  public Float4ValueT() {
    this.X = 0.0f;
    this.Y = 0.0f;
    this.Z = 0.0f;
    this.W = 0.0f;
  }
}

public struct ColorValue : IFlatbufferObject
{
  private Struct __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public void __init(int _i, ByteBuffer _bb) { __p = new Struct(_i, _bb); }
  public ColorValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public byte R { get { return __p.bb.Get(__p.bb_pos + 0); } }
  public byte G { get { return __p.bb.Get(__p.bb_pos + 1); } }
  public byte B { get { return __p.bb.Get(__p.bb_pos + 2); } }
  public byte A { get { return __p.bb.Get(__p.bb_pos + 3); } }

  public static Offset<Fx.ColorValue> CreateColorValue(FlatBufferBuilder builder, byte R, byte G, byte B, byte A) {
    builder.Prep(1, 4);
    builder.PutByte(A);
    builder.PutByte(B);
    builder.PutByte(G);
    builder.PutByte(R);
    return new Offset<Fx.ColorValue>(builder.Offset);
  }
  public ColorValueT UnPack() {
    var _o = new ColorValueT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ColorValueT _o) {
    _o.R = this.R;
    _o.G = this.G;
    _o.B = this.B;
    _o.A = this.A;
  }
  public static Offset<Fx.ColorValue> Pack(FlatBufferBuilder builder, ColorValueT _o) {
    if (_o == null) return default(Offset<Fx.ColorValue>);
    return CreateColorValue(
      builder,
      _o.R,
      _o.G,
      _o.B,
      _o.A);
  }
}

public class ColorValueT
{
  public byte R { get; set; }
  public byte G { get; set; }
  public byte B { get; set; }
  public byte A { get; set; }

  public ColorValueT() {
    this.R = 0;
    this.G = 0;
    this.B = 0;
    this.A = 0;
  }
}

public struct ViewTypeProperty : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static ViewTypeProperty GetRootAsViewTypeProperty(ByteBuffer _bb) { return GetRootAsViewTypeProperty(_bb, new ViewTypeProperty()); }
  public static ViewTypeProperty GetRootAsViewTypeProperty(ByteBuffer _bb, ViewTypeProperty obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public ViewTypeProperty __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.PropertyValue ValueType { get { int o = __p.__offset(6); return o != 0 ? (Fx.PropertyValue)__p.bb.Get(o + __p.bb_pos) : Fx.PropertyValue.NONE; } }
  public TTable? Value<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Fx.UintValue ValueAsUintValue() { return Value<Fx.UintValue>().Value; }
  public Fx.IntValue ValueAsIntValue() { return Value<Fx.IntValue>().Value; }
  public Fx.FloatValue ValueAsFloatValue() { return Value<Fx.FloatValue>().Value; }
  public Fx.StringValue ValueAsStringValue() { return Value<Fx.StringValue>().Value; }

  public static Offset<Fx.ViewTypeProperty> CreateViewTypeProperty(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      Fx.PropertyValue value_type = Fx.PropertyValue.NONE,
      int valueOffset = 0) {
    builder.StartTable(3);
    ViewTypeProperty.AddValue(builder, valueOffset);
    ViewTypeProperty.AddName(builder, nameOffset);
    ViewTypeProperty.AddValueType(builder, value_type);
    return ViewTypeProperty.EndViewTypeProperty(builder);
  }

  public static void StartViewTypeProperty(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddValueType(FlatBufferBuilder builder, Fx.PropertyValue valueType) { builder.AddByte(1, (byte)valueType, 0); }
  public static void AddValue(FlatBufferBuilder builder, int valueOffset) { builder.AddOffset(2, valueOffset, 0); }
  public static Offset<Fx.ViewTypeProperty> EndViewTypeProperty(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.ViewTypeProperty>(o);
  }
  public ViewTypePropertyT UnPack() {
    var _o = new ViewTypePropertyT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(ViewTypePropertyT _o) {
    _o.Name = this.Name;
    _o.Value = new Fx.PropertyValueUnion();
    _o.Value.Type = this.ValueType;
    switch (this.ValueType) {
      default: break;
      case Fx.PropertyValue.UintValue:
        _o.Value.Value = this.Value<Fx.UintValue>().HasValue ? this.Value<Fx.UintValue>().Value.UnPack() : null;
        break;
      case Fx.PropertyValue.IntValue:
        _o.Value.Value = this.Value<Fx.IntValue>().HasValue ? this.Value<Fx.IntValue>().Value.UnPack() : null;
        break;
      case Fx.PropertyValue.FloatValue:
        _o.Value.Value = this.Value<Fx.FloatValue>().HasValue ? this.Value<Fx.FloatValue>().Value.UnPack() : null;
        break;
      case Fx.PropertyValue.StringValue:
        _o.Value.Value = this.Value<Fx.StringValue>().HasValue ? this.Value<Fx.StringValue>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<Fx.ViewTypeProperty> Pack(FlatBufferBuilder builder, ViewTypePropertyT _o) {
    if (_o == null) return default(Offset<Fx.ViewTypeProperty>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _value_type = _o.Value == null ? Fx.PropertyValue.NONE : _o.Value.Type;
    var _value = _o.Value == null ? 0 : Fx.PropertyValueUnion.Pack(builder, _o.Value);
    return CreateViewTypeProperty(
      builder,
      _name,
      _value_type,
      _value);
  }
}

public class ViewTypePropertyT
{
  public string Name { get; set; }
  public Fx.PropertyValueUnion Value { get; set; }

  public ViewTypePropertyT() {
    this.Name = null;
    this.Value = null;
  }
}

public struct UIControl : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static UIControl GetRootAsUIControl(ByteBuffer _bb) { return GetRootAsUIControl(_bb, new UIControl()); }
  public static UIControl GetRootAsUIControl(ByteBuffer _bb, UIControl obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public UIControl __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.ControlValue ValueType { get { int o = __p.__offset(6); return o != 0 ? (Fx.ControlValue)__p.bb.Get(o + __p.bb_pos) : Fx.ControlValue.NONE; } }
  public TTable? Value<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Fx.UintValue ValueAsUintValue() { return Value<Fx.UintValue>().Value; }
  public Fx.IntValue ValueAsIntValue() { return Value<Fx.IntValue>().Value; }
  public Fx.FloatValue ValueAsFloatValue() { return Value<Fx.FloatValue>().Value; }
  public Fx.Float2Value ValueAsFloat2Value() { return Value<Fx.Float2Value>().Value; }
  public Fx.Float3Value ValueAsFloat3Value() { return Value<Fx.Float3Value>().Value; }
  public Fx.Float4Value ValueAsFloat4Value() { return Value<Fx.Float4Value>().Value; }
  public Fx.ColorValue ValueAsColorValue() { return Value<Fx.ColorValue>().Value; }
  public Fx.TextureValue ValueAsTextureValue() { return Value<Fx.TextureValue>().Value; }
  public Fx.MeshValue ValueAsMeshValue() { return Value<Fx.MeshValue>().Value; }
  public Fx.ViewTypeProperty? Properties(int j) { int o = __p.__offset(10); return o != 0 ? (Fx.ViewTypeProperty?)(new Fx.ViewTypeProperty()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PropertiesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.UIControl> CreateUIControl(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      Fx.ControlValue value_type = Fx.ControlValue.NONE,
      int valueOffset = 0,
      VectorOffset propertiesOffset = default(VectorOffset)) {
    builder.StartTable(4);
    UIControl.AddProperties(builder, propertiesOffset);
    UIControl.AddValue(builder, valueOffset);
    UIControl.AddName(builder, nameOffset);
    UIControl.AddValueType(builder, value_type);
    return UIControl.EndUIControl(builder);
  }

  public static void StartUIControl(FlatBufferBuilder builder) { builder.StartTable(4); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddValueType(FlatBufferBuilder builder, Fx.ControlValue valueType) { builder.AddByte(1, (byte)valueType, 0); }
  public static void AddValue(FlatBufferBuilder builder, int valueOffset) { builder.AddOffset(2, valueOffset, 0); }
  public static void AddProperties(FlatBufferBuilder builder, VectorOffset propertiesOffset) { builder.AddOffset(3, propertiesOffset.Value, 0); }
  public static VectorOffset CreatePropertiesVector(FlatBufferBuilder builder, Offset<Fx.ViewTypeProperty>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, Offset<Fx.ViewTypeProperty>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.ViewTypeProperty>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.ViewTypeProperty>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPropertiesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.UIControl> EndUIControl(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.UIControl>(o);
  }
  public UIControlT UnPack() {
    var _o = new UIControlT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(UIControlT _o) {
    _o.Name = this.Name;
    _o.Value = new Fx.ControlValueUnion();
    _o.Value.Type = this.ValueType;
    switch (this.ValueType) {
      default: break;
      case Fx.ControlValue.UintValue:
        _o.Value.Value = this.Value<Fx.UintValue>().HasValue ? this.Value<Fx.UintValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.IntValue:
        _o.Value.Value = this.Value<Fx.IntValue>().HasValue ? this.Value<Fx.IntValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.FloatValue:
        _o.Value.Value = this.Value<Fx.FloatValue>().HasValue ? this.Value<Fx.FloatValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float2Value:
        _o.Value.Value = this.Value<Fx.Float2Value>().HasValue ? this.Value<Fx.Float2Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float3Value:
        _o.Value.Value = this.Value<Fx.Float3Value>().HasValue ? this.Value<Fx.Float3Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float4Value:
        _o.Value.Value = this.Value<Fx.Float4Value>().HasValue ? this.Value<Fx.Float4Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.ColorValue:
        _o.Value.Value = this.Value<Fx.ColorValue>().HasValue ? this.Value<Fx.ColorValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.TextureValue:
        _o.Value.Value = this.Value<Fx.TextureValue>().HasValue ? this.Value<Fx.TextureValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.MeshValue:
        _o.Value.Value = this.Value<Fx.MeshValue>().HasValue ? this.Value<Fx.MeshValue>().Value.UnPack() : null;
        break;
    }
    _o.Properties = new List<Fx.ViewTypePropertyT>();
    for (var _j = 0; _j < this.PropertiesLength; ++_j) {_o.Properties.Add(this.Properties(_j).HasValue ? this.Properties(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.UIControl> Pack(FlatBufferBuilder builder, UIControlT _o) {
    if (_o == null) return default(Offset<Fx.UIControl>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _value_type = _o.Value == null ? Fx.ControlValue.NONE : _o.Value.Type;
    var _value = _o.Value == null ? 0 : Fx.ControlValueUnion.Pack(builder, _o.Value);
    var _properties = default(VectorOffset);
    if (_o.Properties != null) {
      var __properties = new Offset<Fx.ViewTypeProperty>[_o.Properties.Count];
      for (var _j = 0; _j < __properties.Length; ++_j) { __properties[_j] = Fx.ViewTypeProperty.Pack(builder, _o.Properties[_j]); }
      _properties = CreatePropertiesVector(builder, __properties);
    }
    return CreateUIControl(
      builder,
      _name,
      _value_type,
      _value,
      _properties);
  }
}

public class UIControlT
{
  public string Name { get; set; }
  public Fx.ControlValueUnion Value { get; set; }
  public List<Fx.ViewTypePropertyT> Properties { get; set; }

  public UIControlT() {
    this.Name = null;
    this.Value = null;
    this.Properties = null;
  }
}

public struct PresetEntry : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static PresetEntry GetRootAsPresetEntry(ByteBuffer _bb) { return GetRootAsPresetEntry(_bb, new PresetEntry()); }
  public static PresetEntry GetRootAsPresetEntry(ByteBuffer _bb, PresetEntry obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public PresetEntry __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.ControlValue ValueType { get { int o = __p.__offset(6); return o != 0 ? (Fx.ControlValue)__p.bb.Get(o + __p.bb_pos) : Fx.ControlValue.NONE; } }
  public TTable? Value<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Fx.UintValue ValueAsUintValue() { return Value<Fx.UintValue>().Value; }
  public Fx.IntValue ValueAsIntValue() { return Value<Fx.IntValue>().Value; }
  public Fx.FloatValue ValueAsFloatValue() { return Value<Fx.FloatValue>().Value; }
  public Fx.Float2Value ValueAsFloat2Value() { return Value<Fx.Float2Value>().Value; }
  public Fx.Float3Value ValueAsFloat3Value() { return Value<Fx.Float3Value>().Value; }
  public Fx.Float4Value ValueAsFloat4Value() { return Value<Fx.Float4Value>().Value; }
  public Fx.ColorValue ValueAsColorValue() { return Value<Fx.ColorValue>().Value; }
  public Fx.TextureValue ValueAsTextureValue() { return Value<Fx.TextureValue>().Value; }
  public Fx.MeshValue ValueAsMeshValue() { return Value<Fx.MeshValue>().Value; }

  public static Offset<Fx.PresetEntry> CreatePresetEntry(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      Fx.ControlValue value_type = Fx.ControlValue.NONE,
      int valueOffset = 0) {
    builder.StartTable(3);
    PresetEntry.AddValue(builder, valueOffset);
    PresetEntry.AddName(builder, nameOffset);
    PresetEntry.AddValueType(builder, value_type);
    return PresetEntry.EndPresetEntry(builder);
  }

  public static void StartPresetEntry(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddValueType(FlatBufferBuilder builder, Fx.ControlValue valueType) { builder.AddByte(1, (byte)valueType, 0); }
  public static void AddValue(FlatBufferBuilder builder, int valueOffset) { builder.AddOffset(2, valueOffset, 0); }
  public static Offset<Fx.PresetEntry> EndPresetEntry(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.PresetEntry>(o);
  }
  public PresetEntryT UnPack() {
    var _o = new PresetEntryT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PresetEntryT _o) {
    _o.Name = this.Name;
    _o.Value = new Fx.ControlValueUnion();
    _o.Value.Type = this.ValueType;
    switch (this.ValueType) {
      default: break;
      case Fx.ControlValue.UintValue:
        _o.Value.Value = this.Value<Fx.UintValue>().HasValue ? this.Value<Fx.UintValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.IntValue:
        _o.Value.Value = this.Value<Fx.IntValue>().HasValue ? this.Value<Fx.IntValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.FloatValue:
        _o.Value.Value = this.Value<Fx.FloatValue>().HasValue ? this.Value<Fx.FloatValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float2Value:
        _o.Value.Value = this.Value<Fx.Float2Value>().HasValue ? this.Value<Fx.Float2Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float3Value:
        _o.Value.Value = this.Value<Fx.Float3Value>().HasValue ? this.Value<Fx.Float3Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.Float4Value:
        _o.Value.Value = this.Value<Fx.Float4Value>().HasValue ? this.Value<Fx.Float4Value>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.ColorValue:
        _o.Value.Value = this.Value<Fx.ColorValue>().HasValue ? this.Value<Fx.ColorValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.TextureValue:
        _o.Value.Value = this.Value<Fx.TextureValue>().HasValue ? this.Value<Fx.TextureValue>().Value.UnPack() : null;
        break;
      case Fx.ControlValue.MeshValue:
        _o.Value.Value = this.Value<Fx.MeshValue>().HasValue ? this.Value<Fx.MeshValue>().Value.UnPack() : null;
        break;
    }
  }
  public static Offset<Fx.PresetEntry> Pack(FlatBufferBuilder builder, PresetEntryT _o) {
    if (_o == null) return default(Offset<Fx.PresetEntry>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _value_type = _o.Value == null ? Fx.ControlValue.NONE : _o.Value.Type;
    var _value = _o.Value == null ? 0 : Fx.ControlValueUnion.Pack(builder, _o.Value);
    return CreatePresetEntry(
      builder,
      _name,
      _value_type,
      _value);
  }
}

public class PresetEntryT
{
  public string Name { get; set; }
  public Fx.ControlValueUnion Value { get; set; }

  public PresetEntryT() {
    this.Name = null;
    this.Value = null;
  }
}

public struct Preset : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static Preset GetRootAsPreset(ByteBuffer _bb) { return GetRootAsPreset(_bb, new Preset()); }
  public static Preset GetRootAsPreset(ByteBuffer _bb, Preset obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Preset __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public string Desc { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetDescBytes() { return __p.__vector_as_span<byte>(6, 1); }
#else
  public ArraySegment<byte>? GetDescBytes() { return __p.__vector_as_arraysegment(6); }
#endif
  public byte[] GetDescArray() { return __p.__vector_as_array<byte>(6); }
  public Fx.PresetEntry? Data(int j) { int o = __p.__offset(8); return o != 0 ? (Fx.PresetEntry?)(new Fx.PresetEntry()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int DataLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.Preset> CreatePreset(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      StringOffset descOffset = default(StringOffset),
      VectorOffset dataOffset = default(VectorOffset)) {
    builder.StartTable(3);
    Preset.AddData(builder, dataOffset);
    Preset.AddDesc(builder, descOffset);
    Preset.AddName(builder, nameOffset);
    return Preset.EndPreset(builder);
  }

  public static void StartPreset(FlatBufferBuilder builder) { builder.StartTable(3); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddDesc(FlatBufferBuilder builder, StringOffset descOffset) { builder.AddOffset(1, descOffset.Value, 0); }
  public static void AddData(FlatBufferBuilder builder, VectorOffset dataOffset) { builder.AddOffset(2, dataOffset.Value, 0); }
  public static VectorOffset CreateDataVector(FlatBufferBuilder builder, Offset<Fx.PresetEntry>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, Offset<Fx.PresetEntry>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.PresetEntry>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateDataVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.PresetEntry>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartDataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.Preset> EndPreset(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.Preset>(o);
  }
  public PresetT UnPack() {
    var _o = new PresetT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(PresetT _o) {
    _o.Name = this.Name;
    _o.Desc = this.Desc;
    _o.Data = new List<Fx.PresetEntryT>();
    for (var _j = 0; _j < this.DataLength; ++_j) {_o.Data.Add(this.Data(_j).HasValue ? this.Data(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.Preset> Pack(FlatBufferBuilder builder, PresetT _o) {
    if (_o == null) return default(Offset<Fx.Preset>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _desc = _o.Desc == null ? default(StringOffset) : builder.CreateString(_o.Desc);
    var _data = default(VectorOffset);
    if (_o.Data != null) {
      var __data = new Offset<Fx.PresetEntry>[_o.Data.Count];
      for (var _j = 0; _j < __data.Length; ++_j) { __data[_j] = Fx.PresetEntry.Pack(builder, _o.Data[_j]); }
      _data = CreateDataVector(builder, __data);
    }
    return CreatePreset(
      builder,
      _name,
      _desc,
      _data);
  }
}

public class PresetT
{
  public string Name { get; set; }
  public string Desc { get; set; }
  public List<Fx.PresetEntryT> Data { get; set; }

  public PresetT() {
    this.Name = null;
    this.Desc = null;
    this.Data = null;
  }
}

public struct Bundle : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static Bundle GetRootAsBundle(ByteBuffer _bb) { return GetRootAsBundle(_bb, new Bundle()); }
  public static Bundle GetRootAsBundle(ByteBuffer _bb, Bundle obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Bundle __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNameBytes() { return __p.__vector_as_span<byte>(4, 1); }
#else
  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }
#endif
  public byte[] GetNameArray() { return __p.__vector_as_array<byte>(4); }
  public Fx.BundleSignature? Signature { get { int o = __p.__offset(6); return o != 0 ? (Fx.BundleSignature?)(new Fx.BundleSignature()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Fx.BundleMeta? Meta { get { int o = __p.__offset(8); return o != 0 ? (Fx.BundleMeta?)(new Fx.BundleMeta()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
  public Fx.BundleContent ContentType { get { int o = __p.__offset(10); return o != 0 ? (Fx.BundleContent)__p.bb.Get(o + __p.bb_pos) : Fx.BundleContent.NONE; } }
  public TTable? Content<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(12); return o != 0 ? (TTable?)__p.__union<TTable>(o + __p.bb_pos) : null; }
  public Fx.PartBundle ContentAsPartBundle() { return Content<Fx.PartBundle>().Value; }
  public Fx.MatBundle ContentAsMatBundle() { return Content<Fx.MatBundle>().Value; }
  public Fx.Technique11Bundle ContentAsTechnique11Bundle() { return Content<Fx.Technique11Bundle>().Value; }
  public Fx.UIControl? Controls(int j) { int o = __p.__offset(14); return o != 0 ? (Fx.UIControl?)(new Fx.UIControl()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ControlsLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }
  public Fx.Preset? Presets(int j) { int o = __p.__offset(16); return o != 0 ? (Fx.Preset?)(new Fx.Preset()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PresetsLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.Bundle> CreateBundle(FlatBufferBuilder builder,
      StringOffset nameOffset = default(StringOffset),
      Offset<Fx.BundleSignature> signatureOffset = default(Offset<Fx.BundleSignature>),
      Offset<Fx.BundleMeta> metaOffset = default(Offset<Fx.BundleMeta>),
      Fx.BundleContent content_type = Fx.BundleContent.NONE,
      int contentOffset = 0,
      VectorOffset controlsOffset = default(VectorOffset),
      VectorOffset presetsOffset = default(VectorOffset)) {
    builder.StartTable(7);
    Bundle.AddPresets(builder, presetsOffset);
    Bundle.AddControls(builder, controlsOffset);
    Bundle.AddContent(builder, contentOffset);
    Bundle.AddMeta(builder, metaOffset);
    Bundle.AddSignature(builder, signatureOffset);
    Bundle.AddName(builder, nameOffset);
    Bundle.AddContentType(builder, content_type);
    return Bundle.EndBundle(builder);
  }

  public static void StartBundle(FlatBufferBuilder builder) { builder.StartTable(7); }
  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }
  public static void AddSignature(FlatBufferBuilder builder, Offset<Fx.BundleSignature> signatureOffset) { builder.AddOffset(1, signatureOffset.Value, 0); }
  public static void AddMeta(FlatBufferBuilder builder, Offset<Fx.BundleMeta> metaOffset) { builder.AddOffset(2, metaOffset.Value, 0); }
  public static void AddContentType(FlatBufferBuilder builder, Fx.BundleContent contentType) { builder.AddByte(3, (byte)contentType, 0); }
  public static void AddContent(FlatBufferBuilder builder, int contentOffset) { builder.AddOffset(4, contentOffset, 0); }
  public static void AddControls(FlatBufferBuilder builder, VectorOffset controlsOffset) { builder.AddOffset(5, controlsOffset.Value, 0); }
  public static VectorOffset CreateControlsVector(FlatBufferBuilder builder, Offset<Fx.UIControl>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateControlsVectorBlock(FlatBufferBuilder builder, Offset<Fx.UIControl>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateControlsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.UIControl>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateControlsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.UIControl>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartControlsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddPresets(FlatBufferBuilder builder, VectorOffset presetsOffset) { builder.AddOffset(6, presetsOffset.Value, 0); }
  public static VectorOffset CreatePresetsVector(FlatBufferBuilder builder, Offset<Fx.Preset>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePresetsVectorBlock(FlatBufferBuilder builder, Offset<Fx.Preset>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePresetsVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.Preset>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePresetsVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.Preset>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPresetsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.Bundle> EndBundle(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.Bundle>(o);
  }
  public static void FinishBundleBuffer(FlatBufferBuilder builder, Offset<Fx.Bundle> offset) { builder.Finish(offset.Value); }
  public static void FinishSizePrefixedBundleBuffer(FlatBufferBuilder builder, Offset<Fx.Bundle> offset) { builder.FinishSizePrefixed(offset.Value); }
  public BundleT UnPack() {
    var _o = new BundleT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BundleT _o) {
    _o.Name = this.Name;
    _o.Signature = this.Signature.HasValue ? this.Signature.Value.UnPack() : null;
    _o.Meta = this.Meta.HasValue ? this.Meta.Value.UnPack() : null;
    _o.Content = new Fx.BundleContentUnion();
    _o.Content.Type = this.ContentType;
    switch (this.ContentType) {
      default: break;
      case Fx.BundleContent.PartBundle:
        _o.Content.Value = this.Content<Fx.PartBundle>().HasValue ? this.Content<Fx.PartBundle>().Value.UnPack() : null;
        break;
      case Fx.BundleContent.MatBundle:
        _o.Content.Value = this.Content<Fx.MatBundle>().HasValue ? this.Content<Fx.MatBundle>().Value.UnPack() : null;
        break;
      case Fx.BundleContent.Technique11Bundle:
        _o.Content.Value = this.Content<Fx.Technique11Bundle>().HasValue ? this.Content<Fx.Technique11Bundle>().Value.UnPack() : null;
        break;
    }
    _o.Controls = new List<Fx.UIControlT>();
    for (var _j = 0; _j < this.ControlsLength; ++_j) {_o.Controls.Add(this.Controls(_j).HasValue ? this.Controls(_j).Value.UnPack() : null);}
    _o.Presets = new List<Fx.PresetT>();
    for (var _j = 0; _j < this.PresetsLength; ++_j) {_o.Presets.Add(this.Presets(_j).HasValue ? this.Presets(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.Bundle> Pack(FlatBufferBuilder builder, BundleT _o) {
    if (_o == null) return default(Offset<Fx.Bundle>);
    var _name = _o.Name == null ? default(StringOffset) : builder.CreateString(_o.Name);
    var _signature = _o.Signature == null ? default(Offset<Fx.BundleSignature>) : Fx.BundleSignature.Pack(builder, _o.Signature);
    var _meta = _o.Meta == null ? default(Offset<Fx.BundleMeta>) : Fx.BundleMeta.Pack(builder, _o.Meta);
    var _content_type = _o.Content == null ? Fx.BundleContent.NONE : _o.Content.Type;
    var _content = _o.Content == null ? 0 : Fx.BundleContentUnion.Pack(builder, _o.Content);
    var _controls = default(VectorOffset);
    if (_o.Controls != null) {
      var __controls = new Offset<Fx.UIControl>[_o.Controls.Count];
      for (var _j = 0; _j < __controls.Length; ++_j) { __controls[_j] = Fx.UIControl.Pack(builder, _o.Controls[_j]); }
      _controls = CreateControlsVector(builder, __controls);
    }
    var _presets = default(VectorOffset);
    if (_o.Presets != null) {
      var __presets = new Offset<Fx.Preset>[_o.Presets.Count];
      for (var _j = 0; _j < __presets.Length; ++_j) { __presets[_j] = Fx.Preset.Pack(builder, _o.Presets[_j]); }
      _presets = CreatePresetsVector(builder, __presets);
    }
    return CreateBundle(
      builder,
      _name,
      _signature,
      _meta,
      _content_type,
      _content,
      _controls,
      _presets);
  }
}

public class BundleT
{
  public string Name { get; set; }
  public Fx.BundleSignatureT Signature { get; set; }
  public Fx.BundleMetaT Meta { get; set; }
  public Fx.BundleContentUnion Content { get; set; }
  public List<Fx.UIControlT> Controls { get; set; }
  public List<Fx.PresetT> Presets { get; set; }

  public BundleT() {
    this.Name = null;
    this.Signature = null;
    this.Meta = null;
    this.Content = null;
    this.Controls = null;
    this.Presets = null;
  }
  public static BundleT DeserializeFromBinary(byte[] fbBuffer) {
    return Bundle.GetRootAsBundle(new ByteBuffer(fbBuffer)).UnPack();
  }
  public byte[] SerializeToBinary() {
    var fbb = new FlatBufferBuilder(0x10000);
    Bundle.FinishBundleBuffer(fbb, Bundle.Pack(fbb, this));
    return fbb.DataBuffer.ToSizedArray();
  }
}

public struct BundleCollection : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_2_0_0(); }
  public static BundleCollection GetRootAsBundleCollection(ByteBuffer _bb) { return GetRootAsBundleCollection(_bb, new BundleCollection()); }
  public static BundleCollection GetRootAsBundleCollection(ByteBuffer _bb, BundleCollection obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public BundleCollection __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public Fx.Bundle? Content(int j) { int o = __p.__offset(4); return o != 0 ? (Fx.Bundle?)(new Fx.Bundle()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int ContentLength { get { int o = __p.__offset(4); return o != 0 ? __p.__vector_len(o) : 0; } }

  public static Offset<Fx.BundleCollection> CreateBundleCollection(FlatBufferBuilder builder,
      VectorOffset contentOffset = default(VectorOffset)) {
    builder.StartTable(1);
    BundleCollection.AddContent(builder, contentOffset);
    return BundleCollection.EndBundleCollection(builder);
  }

  public static void StartBundleCollection(FlatBufferBuilder builder) { builder.StartTable(1); }
  public static void AddContent(FlatBufferBuilder builder, VectorOffset contentOffset) { builder.AddOffset(0, contentOffset.Value, 0); }
  public static VectorOffset CreateContentVector(FlatBufferBuilder builder, Offset<Fx.Bundle>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, Offset<Fx.Bundle>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<Fx.Bundle>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateContentVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<Fx.Bundle>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartContentVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<Fx.BundleCollection> EndBundleCollection(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<Fx.BundleCollection>(o);
  }
  public BundleCollectionT UnPack() {
    var _o = new BundleCollectionT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(BundleCollectionT _o) {
    _o.Content = new List<Fx.BundleT>();
    for (var _j = 0; _j < this.ContentLength; ++_j) {_o.Content.Add(this.Content(_j).HasValue ? this.Content(_j).Value.UnPack() : null);}
  }
  public static Offset<Fx.BundleCollection> Pack(FlatBufferBuilder builder, BundleCollectionT _o) {
    if (_o == null) return default(Offset<Fx.BundleCollection>);
    var _content = default(VectorOffset);
    if (_o.Content != null) {
      var __content = new Offset<Fx.Bundle>[_o.Content.Count];
      for (var _j = 0; _j < __content.Length; ++_j) { __content[_j] = Fx.Bundle.Pack(builder, _o.Content[_j]); }
      _content = CreateContentVector(builder, __content);
    }
    return CreateBundleCollection(
      builder,
      _content);
  }
}

public class BundleCollectionT
{
  public List<Fx.BundleT> Content { get; set; }

  public BundleCollectionT() {
    this.Content = null;
  }
}


}
