// automatically generated by the FlatBuffers compiler, do not modify

import { FloatValue, FloatValueT } from '../fx/float-value';
import { IntValue, IntValueT } from '../fx/int-value';
import { StringValue, StringValueT } from '../fx/string-value';
import { UintValue, UintValueT } from '../fx/uint-value';


export enum PropertyValue {
  NONE = 0,
  UintValue = 1,
  IntValue = 2,
  FloatValue = 3,
  StringValue = 4
}

export function unionToPropertyValue(
  type: PropertyValue,
  accessor: (obj:FloatValue|IntValue|StringValue|UintValue) => FloatValue|IntValue|StringValue|UintValue|null
): FloatValue|IntValue|StringValue|UintValue|null {
  switch(PropertyValue[type]) {
    case 'NONE': return null; 
    case 'UintValue': return accessor(new UintValue())! as UintValue;
    case 'IntValue': return accessor(new IntValue())! as IntValue;
    case 'FloatValue': return accessor(new FloatValue())! as FloatValue;
    case 'StringValue': return accessor(new StringValue())! as StringValue;
    default: return null;
  }
}

export function unionListToPropertyValue(
  type: PropertyValue, 
  accessor: (index: number, obj:FloatValue|IntValue|StringValue|UintValue) => FloatValue|IntValue|StringValue|UintValue|null, 
  index: number
): FloatValue|IntValue|StringValue|UintValue|null {
  switch(PropertyValue[type]) {
    case 'NONE': return null; 
    case 'UintValue': return accessor(index, new UintValue())! as UintValue;
    case 'IntValue': return accessor(index, new IntValue())! as IntValue;
    case 'FloatValue': return accessor(index, new FloatValue())! as FloatValue;
    case 'StringValue': return accessor(index, new StringValue())! as StringValue;
    default: return null;
  }
}
