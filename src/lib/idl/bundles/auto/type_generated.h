// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPE_H_
#define FLATBUFFERS_GENERATED_TYPE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

struct TypeField;
struct TypeFieldBuilder;
struct TypeFieldT;

struct TypeLayout;
struct TypeLayoutBuilder;
struct TypeLayoutT;

struct TypeFieldT : public flatbuffers::NativeTable {
  typedef TypeField TableType;
  std::unique_ptr<TypeLayoutT> type{};
  std::string name{};
  std::string semantic{};
  uint32_t size = 0;
  uint32_t padding = 0;
  TypeFieldT() = default;
  TypeFieldT(const TypeFieldT &o);
  TypeFieldT(TypeFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeFieldT &operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeFieldT NativeTableType;
  typedef TypeFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_SEMANTIC = 8,
    VT_SIZE = 10,
    VT_PADDING = 12
  };
  const TypeLayout *type() const {
    return GetPointer<const TypeLayout *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *semantic() const {
    return GetPointer<const flatbuffers::String *>(VT_SEMANTIC);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SEMANTIC) &&
           verifier.VerifyString(semantic()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  TypeFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeFieldBuilder {
  typedef TypeField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<TypeLayout> type) {
    fbb_.AddOffset(TypeField::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeField::VT_NAME, name);
  }
  void add_semantic(flatbuffers::Offset<flatbuffers::String> semantic) {
    fbb_.AddOffset(TypeField::VT_SEMANTIC, semantic);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeField::VT_SIZE, size, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(TypeField::VT_PADDING, padding, 0);
  }
  explicit TypeFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeField> CreateTypeField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TypeLayout> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> semantic = 0,
    uint32_t size = 0,
    uint32_t padding = 0) {
  TypeFieldBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_size(size);
  builder_.add_semantic(semantic);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeField> CreateTypeFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TypeLayout> type = 0,
    const char *name = nullptr,
    const char *semantic = nullptr,
    uint32_t size = 0,
    uint32_t padding = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto semantic__ = semantic ? _fbb.CreateString(semantic) : 0;
  return CreateTypeField(
      _fbb,
      type,
      name__,
      semantic__,
      size,
      padding);
}

flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeLayoutT : public flatbuffers::NativeTable {
  typedef TypeLayout TableType;
  std::vector<std::unique_ptr<TypeFieldT>> fields{};
  int32_t length = 0;
  std::string name{};
  uint32_t size = 0;
  TypeLayoutT() = default;
  TypeLayoutT(const TypeLayoutT &o);
  TypeLayoutT(TypeLayoutT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeLayoutT &operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeLayoutT NativeTableType;
  typedef TypeLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4,
    VT_LENGTH = 6,
    VT_NAME = 8,
    VT_SIZE = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<TypeField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TypeField>> *>(VT_FIELDS);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<int32_t>(verifier, VT_LENGTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  TypeLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeLayoutBuilder {
  typedef TypeLayout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TypeField>>> fields) {
    fbb_.AddOffset(TypeLayout::VT_FIELDS, fields);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(TypeLayout::VT_LENGTH, length, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeLayout::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeLayout::VT_SIZE, size, 0);
  }
  explicit TypeLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TypeField>>> fields = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  TypeLayoutBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_length(length);
  builder_.add_fields(fields);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TypeField>> *fields = nullptr,
    int32_t length = 0,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<TypeField>>(*fields) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return CreateTypeLayout(
      _fbb,
      fields__,
      length,
      name__,
      size);
}

flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline TypeFieldT::TypeFieldT(const TypeFieldT &o)
      : type((o.type) ? new TypeLayoutT(*o.type) : nullptr),
        name(o.name),
        semantic(o.semantic),
        size(o.size),
        padding(o.padding) {
}

inline TypeFieldT &TypeFieldT::operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(name, o.name);
  std::swap(semantic, o.semantic);
  std::swap(size, o.size);
  std::swap(padding, o.padding);
  return *this;
}

inline TypeFieldT *TypeField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeFieldT>(new TypeFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeField::UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = std::unique_ptr<TypeLayoutT>(_e->UnPack(_resolver)); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = semantic(); if (_e) _o->semantic = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline flatbuffers::Offset<TypeField> TypeField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _semantic = _o->semantic.empty() ? 0 : _fbb.CreateString(_o->semantic);
  auto _size = _o->size;
  auto _padding = _o->padding;
  return CreateTypeField(
      _fbb,
      _type,
      _name,
      _semantic,
      _size,
      _padding);
}

inline TypeLayoutT::TypeLayoutT(const TypeLayoutT &o)
      : length(o.length),
        name(o.name),
        size(o.size) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new TypeFieldT(*fields_) : nullptr); }
}

inline TypeLayoutT &TypeLayoutT::operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT {
  std::swap(fields, o.fields);
  std::swap(length, o.length);
  std::swap(name, o.name);
  std::swap(size, o.size);
  return *this;
}

inline TypeLayoutT *TypeLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeLayoutT>(new TypeLayoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeLayout::UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->fields[_i] = std::unique_ptr<TypeFieldT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = length(); _o->length = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<TypeLayout> TypeLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<TypeField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateTypeField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _length = _o->length;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  return CreateTypeLayout(
      _fbb,
      _fields,
      _length,
      _name,
      _size);
}

#endif  // FLATBUFFERS_GENERATED_TYPE_H_
