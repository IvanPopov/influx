// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
#define FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace Fx {

struct BundleSignature;
struct BundleSignatureBuilder;
struct BundleSignatureT;

struct BundleMeta;
struct BundleMetaBuilder;
struct BundleMetaT;

struct TypeField;
struct TypeFieldBuilder;
struct TypeFieldT;

struct TypeLayout;
struct TypeLayoutBuilder;
struct TypeLayoutT;

struct UAVBundle;
struct UAVBundleBuilder;
struct UAVBundleT;

struct BufferBundle;
struct BufferBundleBuilder;
struct BufferBundleT;

struct TextureBundle;
struct TextureBundleBuilder;
struct TextureBundleT;

struct TrimeshBundle;
struct TrimeshBundleBuilder;
struct TrimeshBundleT;

struct CBBundle;
struct CBBundleBuilder;
struct CBBundleT;

struct GLSLAttribute;
struct GLSLAttributeBuilder;
struct GLSLAttributeT;

struct RoutineBytecodeBundleResources;
struct RoutineBytecodeBundleResourcesBuilder;
struct RoutineBytecodeBundleResourcesT;

struct RoutineBytecodeBundle;
struct RoutineBytecodeBundleBuilder;
struct RoutineBytecodeBundleT;

struct Pass11BytecodeBundle;
struct Pass11BytecodeBundleBuilder;
struct Pass11BytecodeBundleT;

struct RoutineGLSLSourceBundle;
struct RoutineGLSLSourceBundleBuilder;
struct RoutineGLSLSourceBundleT;

struct RoutineHLSLSourceBundle;
struct RoutineHLSLSourceBundleBuilder;
struct RoutineHLSLSourceBundleT;

struct RoutineShaderBundle;
struct RoutineShaderBundleBuilder;
struct RoutineShaderBundleT;

struct PartRenderPass;
struct PartRenderPassBuilder;
struct PartRenderPassT;

struct PartBundle;
struct PartBundleBuilder;
struct PartBundleT;

struct RenderState;
struct RenderStateBuilder;
struct RenderStateT;

struct MatRenderPass;
struct MatRenderPassBuilder;
struct MatRenderPassT;

struct MatBundle;
struct MatBundleBuilder;
struct MatBundleT;

struct StringValue;
struct StringValueBuilder;
struct StringValueT;

struct TextureValue;
struct TextureValueBuilder;
struct TextureValueT;

struct MeshValue;
struct MeshValueBuilder;
struct MeshValueT;

struct UintValue;

struct IntValue;

struct FloatValue;

struct Float2Value;

struct Float3Value;

struct Float4Value;

struct ColorValue;

struct ViewTypeProperty;
struct ViewTypePropertyBuilder;
struct ViewTypePropertyT;

struct UIControl;
struct UIControlBuilder;
struct UIControlT;

struct PresetEntry;
struct PresetEntryBuilder;
struct PresetEntryT;

struct Preset;
struct PresetBuilder;
struct PresetT;

struct Bundle;
struct BundleBuilder;
struct BundleT;

struct BundleCollection;
struct BundleCollectionBuilder;
struct BundleCollectionT;

enum RoutineBundle : uint8_t {
  RoutineBundle_NONE = 0,
  RoutineBundle_RoutineBytecodeBundle = 1,
  RoutineBundle_RoutineShaderBundle = 2,
  RoutineBundle_MIN = RoutineBundle_NONE,
  RoutineBundle_MAX = RoutineBundle_RoutineShaderBundle
};

inline const RoutineBundle (&EnumValuesRoutineBundle())[3] {
  static const RoutineBundle values[] = {
    RoutineBundle_NONE,
    RoutineBundle_RoutineBytecodeBundle,
    RoutineBundle_RoutineShaderBundle
  };
  return values;
}

inline const char * const *EnumNamesRoutineBundle() {
  static const char * const names[4] = {
    "NONE",
    "RoutineBytecodeBundle",
    "RoutineShaderBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoutineBundle(RoutineBundle e) {
  if (flatbuffers::IsOutRange(e, RoutineBundle_NONE, RoutineBundle_RoutineShaderBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoutineBundle()[index];
}

template<typename T> struct RoutineBundleTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleTraits<Fx::RoutineBytecodeBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleTraits<Fx::RoutineShaderBundle> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineShaderBundle;
};

template<typename T> struct RoutineBundleUnionTraits {
  static const RoutineBundle enum_value = RoutineBundle_NONE;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineBytecodeBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineBytecodeBundle;
};

template<> struct RoutineBundleUnionTraits<Fx::RoutineShaderBundleT> {
  static const RoutineBundle enum_value = RoutineBundle_RoutineShaderBundle;
};

struct RoutineBundleUnion {
  RoutineBundle type;
  void *value;

  RoutineBundleUnion() : type(RoutineBundle_NONE), value(nullptr) {}
  RoutineBundleUnion(RoutineBundleUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(RoutineBundle_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RoutineBundleUnion(const RoutineBundleUnion &);
  RoutineBundleUnion &operator=(const RoutineBundleUnion &u)
    { RoutineBundleUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RoutineBundleUnion &operator=(RoutineBundleUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RoutineBundleUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = RoutineBundleUnionTraits<RT>::enum_value;
    if (type != RoutineBundle_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  const Fx::RoutineBytecodeBundleT *AsRoutineBytecodeBundle() const {
    return type == RoutineBundle_RoutineBytecodeBundle ?
      reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value) : nullptr;
  }
  Fx::RoutineShaderBundleT *AsRoutineShaderBundle() {
    return type == RoutineBundle_RoutineShaderBundle ?
      reinterpret_cast<Fx::RoutineShaderBundleT *>(value) : nullptr;
  }
  const Fx::RoutineShaderBundleT *AsRoutineShaderBundle() const {
    return type == RoutineBundle_RoutineShaderBundle ?
      reinterpret_cast<const Fx::RoutineShaderBundleT *>(value) : nullptr;
  }
};

bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type);
bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum RoutineSourceBundle : uint8_t {
  RoutineSourceBundle_NONE = 0,
  RoutineSourceBundle_RoutineGLSLSourceBundle = 1,
  RoutineSourceBundle_RoutineHLSLSourceBundle = 2,
  RoutineSourceBundle_MIN = RoutineSourceBundle_NONE,
  RoutineSourceBundle_MAX = RoutineSourceBundle_RoutineHLSLSourceBundle
};

inline const RoutineSourceBundle (&EnumValuesRoutineSourceBundle())[3] {
  static const RoutineSourceBundle values[] = {
    RoutineSourceBundle_NONE,
    RoutineSourceBundle_RoutineGLSLSourceBundle,
    RoutineSourceBundle_RoutineHLSLSourceBundle
  };
  return values;
}

inline const char * const *EnumNamesRoutineSourceBundle() {
  static const char * const names[4] = {
    "NONE",
    "RoutineGLSLSourceBundle",
    "RoutineHLSLSourceBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoutineSourceBundle(RoutineSourceBundle e) {
  if (flatbuffers::IsOutRange(e, RoutineSourceBundle_NONE, RoutineSourceBundle_RoutineHLSLSourceBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoutineSourceBundle()[index];
}

template<typename T> struct RoutineSourceBundleTraits {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_NONE;
};

template<> struct RoutineSourceBundleTraits<Fx::RoutineGLSLSourceBundle> {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_RoutineGLSLSourceBundle;
};

template<> struct RoutineSourceBundleTraits<Fx::RoutineHLSLSourceBundle> {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_RoutineHLSLSourceBundle;
};

template<typename T> struct RoutineSourceBundleUnionTraits {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_NONE;
};

template<> struct RoutineSourceBundleUnionTraits<Fx::RoutineGLSLSourceBundleT> {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_RoutineGLSLSourceBundle;
};

template<> struct RoutineSourceBundleUnionTraits<Fx::RoutineHLSLSourceBundleT> {
  static const RoutineSourceBundle enum_value = RoutineSourceBundle_RoutineHLSLSourceBundle;
};

struct RoutineSourceBundleUnion {
  RoutineSourceBundle type;
  void *value;

  RoutineSourceBundleUnion() : type(RoutineSourceBundle_NONE), value(nullptr) {}
  RoutineSourceBundleUnion(RoutineSourceBundleUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(RoutineSourceBundle_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  RoutineSourceBundleUnion(const RoutineSourceBundleUnion &);
  RoutineSourceBundleUnion &operator=(const RoutineSourceBundleUnion &u)
    { RoutineSourceBundleUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  RoutineSourceBundleUnion &operator=(RoutineSourceBundleUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~RoutineSourceBundleUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = RoutineSourceBundleUnionTraits<RT>::enum_value;
    if (type != RoutineSourceBundle_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, RoutineSourceBundle type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::RoutineGLSLSourceBundleT *AsRoutineGLSLSourceBundle() {
    return type == RoutineSourceBundle_RoutineGLSLSourceBundle ?
      reinterpret_cast<Fx::RoutineGLSLSourceBundleT *>(value) : nullptr;
  }
  const Fx::RoutineGLSLSourceBundleT *AsRoutineGLSLSourceBundle() const {
    return type == RoutineSourceBundle_RoutineGLSLSourceBundle ?
      reinterpret_cast<const Fx::RoutineGLSLSourceBundleT *>(value) : nullptr;
  }
  Fx::RoutineHLSLSourceBundleT *AsRoutineHLSLSourceBundle() {
    return type == RoutineSourceBundle_RoutineHLSLSourceBundle ?
      reinterpret_cast<Fx::RoutineHLSLSourceBundleT *>(value) : nullptr;
  }
  const Fx::RoutineHLSLSourceBundleT *AsRoutineHLSLSourceBundle() const {
    return type == RoutineSourceBundle_RoutineHLSLSourceBundle ?
      reinterpret_cast<const Fx::RoutineHLSLSourceBundleT *>(value) : nullptr;
  }
};

bool VerifyRoutineSourceBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineSourceBundle type);
bool VerifyRoutineSourceBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum EPartSimRoutines : int16_t {
  EPartSimRoutines_k_Reset = 0,
  EPartSimRoutines_k_Spawn = 1,
  EPartSimRoutines_k_Init = 2,
  EPartSimRoutines_k_Update = 3,
  EPartSimRoutines_k_Last = 4,
  EPartSimRoutines_MIN = EPartSimRoutines_k_Reset,
  EPartSimRoutines_MAX = EPartSimRoutines_k_Last
};

inline const EPartSimRoutines (&EnumValuesEPartSimRoutines())[5] {
  static const EPartSimRoutines values[] = {
    EPartSimRoutines_k_Reset,
    EPartSimRoutines_k_Spawn,
    EPartSimRoutines_k_Init,
    EPartSimRoutines_k_Update,
    EPartSimRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartSimRoutines() {
  static const char * const names[6] = {
    "k_Reset",
    "k_Spawn",
    "k_Init",
    "k_Update",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartSimRoutines(EPartSimRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartSimRoutines_k_Reset, EPartSimRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartSimRoutines()[index];
}

enum EPartRenderRoutines : int16_t {
  EPartRenderRoutines_k_Prerender = 0,
  EPartRenderRoutines_k_Vertex = 1,
  EPartRenderRoutines_k_Pixel = 2,
  EPartRenderRoutines_k_Last = 3,
  EPartRenderRoutines_MIN = EPartRenderRoutines_k_Prerender,
  EPartRenderRoutines_MAX = EPartRenderRoutines_k_Last
};

inline const EPartRenderRoutines (&EnumValuesEPartRenderRoutines())[4] {
  static const EPartRenderRoutines values[] = {
    EPartRenderRoutines_k_Prerender,
    EPartRenderRoutines_k_Vertex,
    EPartRenderRoutines_k_Pixel,
    EPartRenderRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEPartRenderRoutines() {
  static const char * const names[5] = {
    "k_Prerender",
    "k_Vertex",
    "k_Pixel",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPartRenderRoutines(EPartRenderRoutines e) {
  if (flatbuffers::IsOutRange(e, EPartRenderRoutines_k_Prerender, EPartRenderRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEPartRenderRoutines()[index];
}

enum EMatRenderRoutines : int16_t {
  EMatRenderRoutines_k_Vertex = 0,
  EMatRenderRoutines_k_Pixel = 1,
  EMatRenderRoutines_k_Last = 2,
  EMatRenderRoutines_MIN = EMatRenderRoutines_k_Vertex,
  EMatRenderRoutines_MAX = EMatRenderRoutines_k_Last
};

inline const EMatRenderRoutines (&EnumValuesEMatRenderRoutines())[3] {
  static const EMatRenderRoutines values[] = {
    EMatRenderRoutines_k_Vertex,
    EMatRenderRoutines_k_Pixel,
    EMatRenderRoutines_k_Last
  };
  return values;
}

inline const char * const *EnumNamesEMatRenderRoutines() {
  static const char * const names[4] = {
    "k_Vertex",
    "k_Pixel",
    "k_Last",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMatRenderRoutines(EMatRenderRoutines e) {
  if (flatbuffers::IsOutRange(e, EMatRenderRoutines_k_Vertex, EMatRenderRoutines_k_Last)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEMatRenderRoutines()[index];
}

enum BundleContent : uint8_t {
  BundleContent_NONE = 0,
  BundleContent_PartBundle = 1,
  BundleContent_MatBundle = 2,
  BundleContent_MIN = BundleContent_NONE,
  BundleContent_MAX = BundleContent_MatBundle
};

inline const BundleContent (&EnumValuesBundleContent())[3] {
  static const BundleContent values[] = {
    BundleContent_NONE,
    BundleContent_PartBundle,
    BundleContent_MatBundle
  };
  return values;
}

inline const char * const *EnumNamesBundleContent() {
  static const char * const names[4] = {
    "NONE",
    "PartBundle",
    "MatBundle",
    nullptr
  };
  return names;
}

inline const char *EnumNameBundleContent(BundleContent e) {
  if (flatbuffers::IsOutRange(e, BundleContent_NONE, BundleContent_MatBundle)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBundleContent()[index];
}

template<typename T> struct BundleContentTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentTraits<Fx::PartBundle> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

template<> struct BundleContentTraits<Fx::MatBundle> {
  static const BundleContent enum_value = BundleContent_MatBundle;
};

template<typename T> struct BundleContentUnionTraits {
  static const BundleContent enum_value = BundleContent_NONE;
};

template<> struct BundleContentUnionTraits<Fx::PartBundleT> {
  static const BundleContent enum_value = BundleContent_PartBundle;
};

template<> struct BundleContentUnionTraits<Fx::MatBundleT> {
  static const BundleContent enum_value = BundleContent_MatBundle;
};

struct BundleContentUnion {
  BundleContent type;
  void *value;

  BundleContentUnion() : type(BundleContent_NONE), value(nullptr) {}
  BundleContentUnion(BundleContentUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(BundleContent_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  BundleContentUnion(const BundleContentUnion &);
  BundleContentUnion &operator=(const BundleContentUnion &u)
    { BundleContentUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  BundleContentUnion &operator=(BundleContentUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~BundleContentUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = BundleContentUnionTraits<RT>::enum_value;
    if (type != BundleContent_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::PartBundleT *AsPartBundle() {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<Fx::PartBundleT *>(value) : nullptr;
  }
  const Fx::PartBundleT *AsPartBundle() const {
    return type == BundleContent_PartBundle ?
      reinterpret_cast<const Fx::PartBundleT *>(value) : nullptr;
  }
  Fx::MatBundleT *AsMatBundle() {
    return type == BundleContent_MatBundle ?
      reinterpret_cast<Fx::MatBundleT *>(value) : nullptr;
  }
  const Fx::MatBundleT *AsMatBundle() const {
    return type == BundleContent_MatBundle ?
      reinterpret_cast<const Fx::MatBundleT *>(value) : nullptr;
  }
};

bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type);
bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum PropertyValue : uint8_t {
  PropertyValue_NONE = 0,
  PropertyValue_UintValue = 1,
  PropertyValue_IntValue = 2,
  PropertyValue_FloatValue = 3,
  PropertyValue_StringValue = 4,
  PropertyValue_MIN = PropertyValue_NONE,
  PropertyValue_MAX = PropertyValue_StringValue
};

inline const PropertyValue (&EnumValuesPropertyValue())[5] {
  static const PropertyValue values[] = {
    PropertyValue_NONE,
    PropertyValue_UintValue,
    PropertyValue_IntValue,
    PropertyValue_FloatValue,
    PropertyValue_StringValue
  };
  return values;
}

inline const char * const *EnumNamesPropertyValue() {
  static const char * const names[6] = {
    "NONE",
    "UintValue",
    "IntValue",
    "FloatValue",
    "StringValue",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropertyValue(PropertyValue e) {
  if (flatbuffers::IsOutRange(e, PropertyValue_NONE, PropertyValue_StringValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropertyValue()[index];
}

template<typename T> struct PropertyValueTraits {
  static const PropertyValue enum_value = PropertyValue_NONE;
};

template<> struct PropertyValueTraits<Fx::UintValue> {
  static const PropertyValue enum_value = PropertyValue_UintValue;
};

template<> struct PropertyValueTraits<Fx::IntValue> {
  static const PropertyValue enum_value = PropertyValue_IntValue;
};

template<> struct PropertyValueTraits<Fx::FloatValue> {
  static const PropertyValue enum_value = PropertyValue_FloatValue;
};

template<> struct PropertyValueTraits<Fx::StringValue> {
  static const PropertyValue enum_value = PropertyValue_StringValue;
};

template<typename T> struct PropertyValueUnionTraits {
  static const PropertyValue enum_value = PropertyValue_NONE;
};

template<> struct PropertyValueUnionTraits<Fx::UintValue> {
  static const PropertyValue enum_value = PropertyValue_UintValue;
};

template<> struct PropertyValueUnionTraits<Fx::IntValue> {
  static const PropertyValue enum_value = PropertyValue_IntValue;
};

template<> struct PropertyValueUnionTraits<Fx::FloatValue> {
  static const PropertyValue enum_value = PropertyValue_FloatValue;
};

template<> struct PropertyValueUnionTraits<Fx::StringValueT> {
  static const PropertyValue enum_value = PropertyValue_StringValue;
};

struct PropertyValueUnion {
  PropertyValue type;
  void *value;

  PropertyValueUnion() : type(PropertyValue_NONE), value(nullptr) {}
  PropertyValueUnion(PropertyValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(PropertyValue_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PropertyValueUnion(const PropertyValueUnion &);
  PropertyValueUnion &operator=(const PropertyValueUnion &u)
    { PropertyValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PropertyValueUnion &operator=(PropertyValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PropertyValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = PropertyValueUnionTraits<RT>::enum_value;
    if (type != PropertyValue_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, PropertyValue type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::UintValue *AsUintValue() {
    return type == PropertyValue_UintValue ?
      reinterpret_cast<Fx::UintValue *>(value) : nullptr;
  }
  const Fx::UintValue *AsUintValue() const {
    return type == PropertyValue_UintValue ?
      reinterpret_cast<const Fx::UintValue *>(value) : nullptr;
  }
  Fx::IntValue *AsIntValue() {
    return type == PropertyValue_IntValue ?
      reinterpret_cast<Fx::IntValue *>(value) : nullptr;
  }
  const Fx::IntValue *AsIntValue() const {
    return type == PropertyValue_IntValue ?
      reinterpret_cast<const Fx::IntValue *>(value) : nullptr;
  }
  Fx::FloatValue *AsFloatValue() {
    return type == PropertyValue_FloatValue ?
      reinterpret_cast<Fx::FloatValue *>(value) : nullptr;
  }
  const Fx::FloatValue *AsFloatValue() const {
    return type == PropertyValue_FloatValue ?
      reinterpret_cast<const Fx::FloatValue *>(value) : nullptr;
  }
  Fx::StringValueT *AsStringValue() {
    return type == PropertyValue_StringValue ?
      reinterpret_cast<Fx::StringValueT *>(value) : nullptr;
  }
  const Fx::StringValueT *AsStringValue() const {
    return type == PropertyValue_StringValue ?
      reinterpret_cast<const Fx::StringValueT *>(value) : nullptr;
  }
};

bool VerifyPropertyValue(flatbuffers::Verifier &verifier, const void *obj, PropertyValue type);
bool VerifyPropertyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum ControlValue : uint8_t {
  ControlValue_NONE = 0,
  ControlValue_UintValue = 1,
  ControlValue_IntValue = 2,
  ControlValue_FloatValue = 3,
  ControlValue_Float2Value = 4,
  ControlValue_Float3Value = 5,
  ControlValue_Float4Value = 6,
  ControlValue_ColorValue = 7,
  ControlValue_TextureValue = 8,
  ControlValue_MeshValue = 9,
  ControlValue_MIN = ControlValue_NONE,
  ControlValue_MAX = ControlValue_MeshValue
};

inline const ControlValue (&EnumValuesControlValue())[10] {
  static const ControlValue values[] = {
    ControlValue_NONE,
    ControlValue_UintValue,
    ControlValue_IntValue,
    ControlValue_FloatValue,
    ControlValue_Float2Value,
    ControlValue_Float3Value,
    ControlValue_Float4Value,
    ControlValue_ColorValue,
    ControlValue_TextureValue,
    ControlValue_MeshValue
  };
  return values;
}

inline const char * const *EnumNamesControlValue() {
  static const char * const names[11] = {
    "NONE",
    "UintValue",
    "IntValue",
    "FloatValue",
    "Float2Value",
    "Float3Value",
    "Float4Value",
    "ColorValue",
    "TextureValue",
    "MeshValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameControlValue(ControlValue e) {
  if (flatbuffers::IsOutRange(e, ControlValue_NONE, ControlValue_MeshValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesControlValue()[index];
}

template<typename T> struct ControlValueTraits {
  static const ControlValue enum_value = ControlValue_NONE;
};

template<> struct ControlValueTraits<Fx::UintValue> {
  static const ControlValue enum_value = ControlValue_UintValue;
};

template<> struct ControlValueTraits<Fx::IntValue> {
  static const ControlValue enum_value = ControlValue_IntValue;
};

template<> struct ControlValueTraits<Fx::FloatValue> {
  static const ControlValue enum_value = ControlValue_FloatValue;
};

template<> struct ControlValueTraits<Fx::Float2Value> {
  static const ControlValue enum_value = ControlValue_Float2Value;
};

template<> struct ControlValueTraits<Fx::Float3Value> {
  static const ControlValue enum_value = ControlValue_Float3Value;
};

template<> struct ControlValueTraits<Fx::Float4Value> {
  static const ControlValue enum_value = ControlValue_Float4Value;
};

template<> struct ControlValueTraits<Fx::ColorValue> {
  static const ControlValue enum_value = ControlValue_ColorValue;
};

template<> struct ControlValueTraits<Fx::TextureValue> {
  static const ControlValue enum_value = ControlValue_TextureValue;
};

template<> struct ControlValueTraits<Fx::MeshValue> {
  static const ControlValue enum_value = ControlValue_MeshValue;
};

template<typename T> struct ControlValueUnionTraits {
  static const ControlValue enum_value = ControlValue_NONE;
};

template<> struct ControlValueUnionTraits<Fx::UintValue> {
  static const ControlValue enum_value = ControlValue_UintValue;
};

template<> struct ControlValueUnionTraits<Fx::IntValue> {
  static const ControlValue enum_value = ControlValue_IntValue;
};

template<> struct ControlValueUnionTraits<Fx::FloatValue> {
  static const ControlValue enum_value = ControlValue_FloatValue;
};

template<> struct ControlValueUnionTraits<Fx::Float2Value> {
  static const ControlValue enum_value = ControlValue_Float2Value;
};

template<> struct ControlValueUnionTraits<Fx::Float3Value> {
  static const ControlValue enum_value = ControlValue_Float3Value;
};

template<> struct ControlValueUnionTraits<Fx::Float4Value> {
  static const ControlValue enum_value = ControlValue_Float4Value;
};

template<> struct ControlValueUnionTraits<Fx::ColorValue> {
  static const ControlValue enum_value = ControlValue_ColorValue;
};

template<> struct ControlValueUnionTraits<Fx::TextureValueT> {
  static const ControlValue enum_value = ControlValue_TextureValue;
};

template<> struct ControlValueUnionTraits<Fx::MeshValueT> {
  static const ControlValue enum_value = ControlValue_MeshValue;
};

struct ControlValueUnion {
  ControlValue type;
  void *value;

  ControlValueUnion() : type(ControlValue_NONE), value(nullptr) {}
  ControlValueUnion(ControlValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ControlValue_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ControlValueUnion(const ControlValueUnion &);
  ControlValueUnion &operator=(const ControlValueUnion &u)
    { ControlValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ControlValueUnion &operator=(ControlValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ControlValueUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ControlValueUnionTraits<RT>::enum_value;
    if (type != ControlValue_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ControlValue type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Fx::UintValue *AsUintValue() {
    return type == ControlValue_UintValue ?
      reinterpret_cast<Fx::UintValue *>(value) : nullptr;
  }
  const Fx::UintValue *AsUintValue() const {
    return type == ControlValue_UintValue ?
      reinterpret_cast<const Fx::UintValue *>(value) : nullptr;
  }
  Fx::IntValue *AsIntValue() {
    return type == ControlValue_IntValue ?
      reinterpret_cast<Fx::IntValue *>(value) : nullptr;
  }
  const Fx::IntValue *AsIntValue() const {
    return type == ControlValue_IntValue ?
      reinterpret_cast<const Fx::IntValue *>(value) : nullptr;
  }
  Fx::FloatValue *AsFloatValue() {
    return type == ControlValue_FloatValue ?
      reinterpret_cast<Fx::FloatValue *>(value) : nullptr;
  }
  const Fx::FloatValue *AsFloatValue() const {
    return type == ControlValue_FloatValue ?
      reinterpret_cast<const Fx::FloatValue *>(value) : nullptr;
  }
  Fx::Float2Value *AsFloat2Value() {
    return type == ControlValue_Float2Value ?
      reinterpret_cast<Fx::Float2Value *>(value) : nullptr;
  }
  const Fx::Float2Value *AsFloat2Value() const {
    return type == ControlValue_Float2Value ?
      reinterpret_cast<const Fx::Float2Value *>(value) : nullptr;
  }
  Fx::Float3Value *AsFloat3Value() {
    return type == ControlValue_Float3Value ?
      reinterpret_cast<Fx::Float3Value *>(value) : nullptr;
  }
  const Fx::Float3Value *AsFloat3Value() const {
    return type == ControlValue_Float3Value ?
      reinterpret_cast<const Fx::Float3Value *>(value) : nullptr;
  }
  Fx::Float4Value *AsFloat4Value() {
    return type == ControlValue_Float4Value ?
      reinterpret_cast<Fx::Float4Value *>(value) : nullptr;
  }
  const Fx::Float4Value *AsFloat4Value() const {
    return type == ControlValue_Float4Value ?
      reinterpret_cast<const Fx::Float4Value *>(value) : nullptr;
  }
  Fx::ColorValue *AsColorValue() {
    return type == ControlValue_ColorValue ?
      reinterpret_cast<Fx::ColorValue *>(value) : nullptr;
  }
  const Fx::ColorValue *AsColorValue() const {
    return type == ControlValue_ColorValue ?
      reinterpret_cast<const Fx::ColorValue *>(value) : nullptr;
  }
  Fx::TextureValueT *AsTextureValue() {
    return type == ControlValue_TextureValue ?
      reinterpret_cast<Fx::TextureValueT *>(value) : nullptr;
  }
  const Fx::TextureValueT *AsTextureValue() const {
    return type == ControlValue_TextureValue ?
      reinterpret_cast<const Fx::TextureValueT *>(value) : nullptr;
  }
  Fx::MeshValueT *AsMeshValue() {
    return type == ControlValue_MeshValue ?
      reinterpret_cast<Fx::MeshValueT *>(value) : nullptr;
  }
  const Fx::MeshValueT *AsMeshValue() const {
    return type == ControlValue_MeshValue ?
      reinterpret_cast<const Fx::MeshValueT *>(value) : nullptr;
  }
};

bool VerifyControlValue(flatbuffers::Verifier &verifier, const void *obj, ControlValue type);
bool VerifyControlValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) UintValue FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t value_;

 public:
  UintValue()
      : value_(0) {
  }
  UintValue(uint32_t _value)
      : value_(flatbuffers::EndianScalar(_value)) {
  }
  uint32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(UintValue, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) IntValue FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_;

 public:
  IntValue()
      : value_(0) {
  }
  IntValue(int32_t _value)
      : value_(flatbuffers::EndianScalar(_value)) {
  }
  int32_t value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(IntValue, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FloatValue FLATBUFFERS_FINAL_CLASS {
 private:
  float value_;

 public:
  FloatValue()
      : value_(0) {
  }
  FloatValue(float _value)
      : value_(flatbuffers::EndianScalar(_value)) {
  }
  float value() const {
    return flatbuffers::EndianScalar(value_);
  }
};
FLATBUFFERS_STRUCT_END(FloatValue, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float2Value FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Float2Value()
      : x_(0),
        y_(0) {
  }
  Float2Value(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Float2Value, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float3Value FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Float3Value()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Float3Value(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Float3Value, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Float4Value FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Float4Value()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Float4Value(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Float4Value, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) ColorValue FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  ColorValue()
      : r_(0),
        g_(0),
        b_(0),
        a_(0) {
  }
  ColorValue(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(ColorValue, 4);

struct BundleSignatureT : public flatbuffers::NativeTable {
  typedef BundleSignature TableType;
  std::string mode{};
  std::string version{};
  std::string commithash{};
  std::string branch{};
  std::string timestamp{};
};

struct BundleSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleSignatureT NativeTableType;
  typedef BundleSignatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_VERSION = 6,
    VT_COMMITHASH = 8,
    VT_BRANCH = 10,
    VT_TIMESTAMP = 12
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *commithash() const {
    return GetPointer<const flatbuffers::String *>(VT_COMMITHASH);
  }
  const flatbuffers::String *branch() const {
    return GetPointer<const flatbuffers::String *>(VT_BRANCH);
  }
  const flatbuffers::String *timestamp() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMESTAMP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_COMMITHASH) &&
           verifier.VerifyString(commithash()) &&
           VerifyOffset(verifier, VT_BRANCH) &&
           verifier.VerifyString(branch()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyString(timestamp()) &&
           verifier.EndTable();
  }
  BundleSignatureT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleSignature> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleSignatureBuilder {
  typedef BundleSignature Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(BundleSignature::VT_MODE, mode);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(BundleSignature::VT_VERSION, version);
  }
  void add_commithash(flatbuffers::Offset<flatbuffers::String> commithash) {
    fbb_.AddOffset(BundleSignature::VT_COMMITHASH, commithash);
  }
  void add_branch(flatbuffers::Offset<flatbuffers::String> branch) {
    fbb_.AddOffset(BundleSignature::VT_BRANCH, branch);
  }
  void add_timestamp(flatbuffers::Offset<flatbuffers::String> timestamp) {
    fbb_.AddOffset(BundleSignature::VT_TIMESTAMP, timestamp);
  }
  explicit BundleSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleSignature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleSignature>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> commithash = 0,
    flatbuffers::Offset<flatbuffers::String> branch = 0,
    flatbuffers::Offset<flatbuffers::String> timestamp = 0) {
  BundleSignatureBuilder builder_(_fbb);
  builder_.add_timestamp(timestamp);
  builder_.add_branch(branch);
  builder_.add_commithash(commithash);
  builder_.add_version(version);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const char *version = nullptr,
    const char *commithash = nullptr,
    const char *branch = nullptr,
    const char *timestamp = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto commithash__ = commithash ? _fbb.CreateString(commithash) : 0;
  auto branch__ = branch ? _fbb.CreateString(branch) : 0;
  auto timestamp__ = timestamp ? _fbb.CreateString(timestamp) : 0;
  return Fx::CreateBundleSignature(
      _fbb,
      mode__,
      version__,
      commithash__,
      branch__,
      timestamp__);
}

flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleMetaT : public flatbuffers::NativeTable {
  typedef BundleMeta TableType;
  std::string author{};
  std::string source{};
};

struct BundleMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleMetaT NativeTableType;
  typedef BundleMetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTHOR = 4,
    VT_SOURCE = 6
  };
  const flatbuffers::String *author() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTHOR);
  }
  const flatbuffers::String *source() const {
    return GetPointer<const flatbuffers::String *>(VT_SOURCE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(author()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           verifier.EndTable();
  }
  BundleMetaT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleMetaT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleMeta> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleMetaBuilder {
  typedef BundleMeta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_author(flatbuffers::Offset<flatbuffers::String> author) {
    fbb_.AddOffset(BundleMeta::VT_AUTHOR, author);
  }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) {
    fbb_.AddOffset(BundleMeta::VT_SOURCE, source);
  }
  explicit BundleMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleMeta> CreateBundleMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> author = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0) {
  BundleMetaBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_author(author);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleMeta> CreateBundleMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *author = nullptr,
    const char *source = nullptr) {
  auto author__ = author ? _fbb.CreateString(author) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  return Fx::CreateBundleMeta(
      _fbb,
      author__,
      source__);
}

flatbuffers::Offset<BundleMeta> CreateBundleMeta(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeFieldT : public flatbuffers::NativeTable {
  typedef TypeField TableType;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  std::string name{};
  std::string semantic{};
  uint32_t size = 0;
  uint32_t padding = 0;
  TypeFieldT() = default;
  TypeFieldT(const TypeFieldT &o);
  TypeFieldT(TypeFieldT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeFieldT &operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeField FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeFieldT NativeTableType;
  typedef TypeFieldBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_SEMANTIC = 8,
    VT_SIZE = 10,
    VT_PADDING = 12
  };
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *semantic() const {
    return GetPointer<const flatbuffers::String *>(VT_SEMANTIC);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t padding() const {
    return GetField<uint32_t>(VT_PADDING, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SEMANTIC) &&
           verifier.VerifyString(semantic()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_PADDING, 4) &&
           verifier.EndTable();
  }
  TypeFieldT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeField> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeFieldBuilder {
  typedef TypeField Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(TypeField::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeField::VT_NAME, name);
  }
  void add_semantic(flatbuffers::Offset<flatbuffers::String> semantic) {
    fbb_.AddOffset(TypeField::VT_SEMANTIC, semantic);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeField::VT_SIZE, size, 0);
  }
  void add_padding(uint32_t padding) {
    fbb_.AddElement<uint32_t>(TypeField::VT_PADDING, padding, 0);
  }
  explicit TypeFieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeField> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeField>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeField> CreateTypeField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> semantic = 0,
    uint32_t size = 0,
    uint32_t padding = 0) {
  TypeFieldBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_size(size);
  builder_.add_semantic(semantic);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeField> CreateTypeFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Fx::TypeLayout> type = 0,
    const char *name = nullptr,
    const char *semantic = nullptr,
    uint32_t size = 0,
    uint32_t padding = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto semantic__ = semantic ? _fbb.CreateString(semantic) : 0;
  return Fx::CreateTypeField(
      _fbb,
      type,
      name__,
      semantic__,
      size,
      padding);
}

flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TypeLayoutT : public flatbuffers::NativeTable {
  typedef TypeLayout TableType;
  std::vector<std::unique_ptr<Fx::TypeFieldT>> fields{};
  int32_t length = 0;
  std::string name{};
  uint32_t size = 0;
  TypeLayoutT() = default;
  TypeLayoutT(const TypeLayoutT &o);
  TypeLayoutT(TypeLayoutT&&) FLATBUFFERS_NOEXCEPT = default;
  TypeLayoutT &operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT;
};

struct TypeLayout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TypeLayoutT NativeTableType;
  typedef TypeLayoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDS = 4,
    VT_LENGTH = 6,
    VT_NAME = 8,
    VT_SIZE = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *>(VT_FIELDS);
  }
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<int32_t>(verifier, VT_LENGTH, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  TypeLayoutT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TypeLayout> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TypeLayoutBuilder {
  typedef TypeLayout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields) {
    fbb_.AddOffset(TypeLayout::VT_FIELDS, fields);
  }
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(TypeLayout::VT_LENGTH, length, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TypeLayout::VT_NAME, name);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(TypeLayout::VT_SIZE, size, 0);
  }
  explicit TypeLayoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TypeLayout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TypeLayout>(end);
    return o;
  }
};

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields = 0,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t size = 0) {
  TypeLayoutBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_length(length);
  builder_.add_fields(fields);
  return builder_.Finish();
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayoutDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::TypeField>> *fields = nullptr,
    int32_t length = 0,
    const char *name = nullptr,
    uint32_t size = 0) {
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>>(*fields) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTypeLayout(
      _fbb,
      fields__,
      length,
      name__,
      size);
}

flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UAVBundleT : public flatbuffers::NativeTable {
  typedef UAVBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  UAVBundleT() = default;
  UAVBundleT(const UAVBundleT &o);
  UAVBundleT(UAVBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  UAVBundleT &operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct UAVBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UAVBundleT NativeTableType;
  typedef UAVBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_STRIDE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  UAVBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UAVBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UAVBundleBuilder {
  typedef UAVBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UAVBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_SLOT, slot, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(UAVBundle::VT_STRIDE, stride, 0);
  }
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(UAVBundle::VT_TYPE, type);
  }
  explicit UAVBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UAVBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UAVBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  UAVBundleBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_stride(stride);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      name__,
      slot,
      stride,
      type);
}

flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BufferBundleT : public flatbuffers::NativeTable {
  typedef BufferBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  BufferBundleT() = default;
  BufferBundleT(const BufferBundleT &o);
  BufferBundleT(BufferBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  BufferBundleT &operator=(BufferBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct BufferBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BufferBundleT NativeTableType;
  typedef BufferBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_STRIDE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  BufferBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BufferBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BufferBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BufferBundleBuilder {
  typedef BufferBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(BufferBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(BufferBundle::VT_SLOT, slot, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(BufferBundle::VT_STRIDE, stride, 0);
  }
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(BufferBundle::VT_TYPE, type);
  }
  explicit BufferBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BufferBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BufferBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<BufferBundle> CreateBufferBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  BufferBundleBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_stride(stride);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<BufferBundle> CreateBufferBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateBufferBundle(
      _fbb,
      name__,
      slot,
      stride,
      type);
}

flatbuffers::Offset<BufferBundle> CreateBufferBundle(flatbuffers::FlatBufferBuilder &_fbb, const BufferBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextureBundleT : public flatbuffers::NativeTable {
  typedef TextureBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> type{};
  TextureBundleT() = default;
  TextureBundleT(const TextureBundleT &o);
  TextureBundleT(TextureBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  TextureBundleT &operator=(TextureBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct TextureBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureBundleT NativeTableType;
  typedef TextureBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_STRIDE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *type() const {
    return GetPointer<const Fx::TypeLayout *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
  TextureBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextureBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TextureBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextureBundleBuilder {
  typedef TextureBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TextureBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(TextureBundle::VT_SLOT, slot, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(TextureBundle::VT_STRIDE, stride, 0);
  }
  void add_type(flatbuffers::Offset<Fx::TypeLayout> type) {
    fbb_.AddOffset(TextureBundle::VT_TYPE, type);
  }
  explicit TextureBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureBundle> CreateTextureBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  TextureBundleBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_stride(stride);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureBundle> CreateTextureBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> type = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateTextureBundle(
      _fbb,
      name__,
      slot,
      stride,
      type);
}

flatbuffers::Offset<TextureBundle> CreateTextureBundle(flatbuffers::FlatBufferBuilder &_fbb, const TextureBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TrimeshBundleT : public flatbuffers::NativeTable {
  typedef TrimeshBundle TableType;
  std::string name{};
  std::string vertexCountUName{};
  std::string faceCountUName{};
  std::string verticesName{};
  std::string facesName{};
  std::string gsAdjecencyName{};
  std::string faceAdjacencyName{};
};

struct TrimeshBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TrimeshBundleT NativeTableType;
  typedef TrimeshBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERTEXCOUNTUNAME = 6,
    VT_FACECOUNTUNAME = 8,
    VT_VERTICESNAME = 10,
    VT_FACESNAME = 12,
    VT_GSADJECENCYNAME = 14,
    VT_FACEADJACENCYNAME = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *vertexCountUName() const {
    return GetPointer<const flatbuffers::String *>(VT_VERTEXCOUNTUNAME);
  }
  const flatbuffers::String *faceCountUName() const {
    return GetPointer<const flatbuffers::String *>(VT_FACECOUNTUNAME);
  }
  const flatbuffers::String *verticesName() const {
    return GetPointer<const flatbuffers::String *>(VT_VERTICESNAME);
  }
  const flatbuffers::String *facesName() const {
    return GetPointer<const flatbuffers::String *>(VT_FACESNAME);
  }
  const flatbuffers::String *gsAdjecencyName() const {
    return GetPointer<const flatbuffers::String *>(VT_GSADJECENCYNAME);
  }
  const flatbuffers::String *faceAdjacencyName() const {
    return GetPointer<const flatbuffers::String *>(VT_FACEADJACENCYNAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERTEXCOUNTUNAME) &&
           verifier.VerifyString(vertexCountUName()) &&
           VerifyOffset(verifier, VT_FACECOUNTUNAME) &&
           verifier.VerifyString(faceCountUName()) &&
           VerifyOffset(verifier, VT_VERTICESNAME) &&
           verifier.VerifyString(verticesName()) &&
           VerifyOffset(verifier, VT_FACESNAME) &&
           verifier.VerifyString(facesName()) &&
           VerifyOffset(verifier, VT_GSADJECENCYNAME) &&
           verifier.VerifyString(gsAdjecencyName()) &&
           VerifyOffset(verifier, VT_FACEADJACENCYNAME) &&
           verifier.VerifyString(faceAdjacencyName()) &&
           verifier.EndTable();
  }
  TrimeshBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TrimeshBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TrimeshBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrimeshBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TrimeshBundleBuilder {
  typedef TrimeshBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TrimeshBundle::VT_NAME, name);
  }
  void add_vertexCountUName(flatbuffers::Offset<flatbuffers::String> vertexCountUName) {
    fbb_.AddOffset(TrimeshBundle::VT_VERTEXCOUNTUNAME, vertexCountUName);
  }
  void add_faceCountUName(flatbuffers::Offset<flatbuffers::String> faceCountUName) {
    fbb_.AddOffset(TrimeshBundle::VT_FACECOUNTUNAME, faceCountUName);
  }
  void add_verticesName(flatbuffers::Offset<flatbuffers::String> verticesName) {
    fbb_.AddOffset(TrimeshBundle::VT_VERTICESNAME, verticesName);
  }
  void add_facesName(flatbuffers::Offset<flatbuffers::String> facesName) {
    fbb_.AddOffset(TrimeshBundle::VT_FACESNAME, facesName);
  }
  void add_gsAdjecencyName(flatbuffers::Offset<flatbuffers::String> gsAdjecencyName) {
    fbb_.AddOffset(TrimeshBundle::VT_GSADJECENCYNAME, gsAdjecencyName);
  }
  void add_faceAdjacencyName(flatbuffers::Offset<flatbuffers::String> faceAdjacencyName) {
    fbb_.AddOffset(TrimeshBundle::VT_FACEADJACENCYNAME, faceAdjacencyName);
  }
  explicit TrimeshBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TrimeshBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TrimeshBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<TrimeshBundle> CreateTrimeshBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> vertexCountUName = 0,
    flatbuffers::Offset<flatbuffers::String> faceCountUName = 0,
    flatbuffers::Offset<flatbuffers::String> verticesName = 0,
    flatbuffers::Offset<flatbuffers::String> facesName = 0,
    flatbuffers::Offset<flatbuffers::String> gsAdjecencyName = 0,
    flatbuffers::Offset<flatbuffers::String> faceAdjacencyName = 0) {
  TrimeshBundleBuilder builder_(_fbb);
  builder_.add_faceAdjacencyName(faceAdjacencyName);
  builder_.add_gsAdjecencyName(gsAdjecencyName);
  builder_.add_facesName(facesName);
  builder_.add_verticesName(verticesName);
  builder_.add_faceCountUName(faceCountUName);
  builder_.add_vertexCountUName(vertexCountUName);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<TrimeshBundle> CreateTrimeshBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *vertexCountUName = nullptr,
    const char *faceCountUName = nullptr,
    const char *verticesName = nullptr,
    const char *facesName = nullptr,
    const char *gsAdjecencyName = nullptr,
    const char *faceAdjacencyName = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto vertexCountUName__ = vertexCountUName ? _fbb.CreateString(vertexCountUName) : 0;
  auto faceCountUName__ = faceCountUName ? _fbb.CreateString(faceCountUName) : 0;
  auto verticesName__ = verticesName ? _fbb.CreateString(verticesName) : 0;
  auto facesName__ = facesName ? _fbb.CreateString(facesName) : 0;
  auto gsAdjecencyName__ = gsAdjecencyName ? _fbb.CreateString(gsAdjecencyName) : 0;
  auto faceAdjacencyName__ = faceAdjacencyName ? _fbb.CreateString(faceAdjacencyName) : 0;
  return Fx::CreateTrimeshBundle(
      _fbb,
      name__,
      vertexCountUName__,
      faceCountUName__,
      verticesName__,
      facesName__,
      gsAdjecencyName__,
      faceAdjacencyName__);
}

flatbuffers::Offset<TrimeshBundle> CreateTrimeshBundle(flatbuffers::FlatBufferBuilder &_fbb, const TrimeshBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CBBundleT : public flatbuffers::NativeTable {
  typedef CBBundle TableType;
  std::string name{};
  uint32_t slot = 0;
  uint32_t size = 0;
  std::vector<std::unique_ptr<Fx::TypeFieldT>> fields{};
  CBBundleT() = default;
  CBBundleT(const CBBundleT &o);
  CBBundleT(CBBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  CBBundleT &operator=(CBBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct CBBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CBBundleT NativeTableType;
  typedef CBBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SLOT = 6,
    VT_SIZE = 8,
    VT_FIELDS = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint32_t slot() const {
    return GetField<uint32_t>(VT_SLOT, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *fields() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>> *>(VT_FIELDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_SLOT, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           verifier.EndTable();
  }
  CBBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CBBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CBBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CBBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CBBundleBuilder {
  typedef CBBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CBBundle::VT_NAME, name);
  }
  void add_slot(uint32_t slot) {
    fbb_.AddElement<uint32_t>(CBBundle::VT_SLOT, slot, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(CBBundle::VT_SIZE, size, 0);
  }
  void add_fields(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields) {
    fbb_.AddOffset(CBBundle::VT_FIELDS, fields);
  }
  explicit CBBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CBBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CBBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<CBBundle> CreateCBBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint32_t slot = 0,
    uint32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TypeField>>> fields = 0) {
  CBBundleBuilder builder_(_fbb);
  builder_.add_fields(fields);
  builder_.add_size(size);
  builder_.add_slot(slot);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CBBundle> CreateCBBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t slot = 0,
    uint32_t size = 0,
    const std::vector<flatbuffers::Offset<Fx::TypeField>> *fields = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto fields__ = fields ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>>(*fields) : 0;
  return Fx::CreateCBBundle(
      _fbb,
      name__,
      slot,
      size,
      fields__);
}

flatbuffers::Offset<CBBundle> CreateCBBundle(flatbuffers::FlatBufferBuilder &_fbb, const CBBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GLSLAttributeT : public flatbuffers::NativeTable {
  typedef GLSLAttribute TableType;
  uint32_t size = 0;
  uint32_t offset = 0;
  std::string name{};
};

struct GLSLAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLSLAttributeT NativeTableType;
  typedef GLSLAttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZE = 4,
    VT_OFFSET = 6,
    VT_NAME = 8
  };
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  GLSLAttributeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GLSLAttribute> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GLSLAttributeBuilder {
  typedef GLSLAttribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_SIZE, size, 0);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(GLSLAttribute::VT_OFFSET, offset, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GLSLAttribute::VT_NAME, name);
  }
  explicit GLSLAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLSLAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLSLAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GLSLAttributeBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_size(size);
  return builder_.Finish();
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t size = 0,
    uint32_t offset = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateGLSLAttribute(
      _fbb,
      size,
      offset,
      name__);
}

flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleResourcesT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundleResources TableType;
  std::vector<std::unique_ptr<Fx::UAVBundleT>> uavs{};
  std::vector<std::unique_ptr<Fx::BufferBundleT>> buffers{};
  std::vector<std::unique_ptr<Fx::TextureBundleT>> textures{};
  std::vector<std::unique_ptr<Fx::TrimeshBundleT>> trimeshes{};
  RoutineBytecodeBundleResourcesT() = default;
  RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o);
  RoutineBytecodeBundleResourcesT(RoutineBytecodeBundleResourcesT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleResourcesT &operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundleResources FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleResourcesT NativeTableType;
  typedef RoutineBytecodeBundleResourcesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UAVS = 4,
    VT_BUFFERS = 6,
    VT_TEXTURES = 8,
    VT_TRIMESHES = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>> *>(VT_UAVS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::BufferBundle>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::BufferBundle>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TextureBundle>> *textures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TextureBundle>> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::TrimeshBundle>> *trimeshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::TrimeshBundle>> *>(VT_TRIMESHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UAVS) &&
           verifier.VerifyVector(uavs()) &&
           verifier.VerifyVectorOfTables(uavs()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           VerifyOffset(verifier, VT_TRIMESHES) &&
           verifier.VerifyVector(trimeshes()) &&
           verifier.VerifyVectorOfTables(trimeshes()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleResourcesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundleResources> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleResourcesBuilder {
  typedef RoutineBytecodeBundleResources Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uavs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_UAVS, uavs);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::BufferBundle>>> buffers) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_BUFFERS, buffers);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TextureBundle>>> textures) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_TEXTURES, textures);
  }
  void add_trimeshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TrimeshBundle>>> trimeshes) {
    fbb_.AddOffset(RoutineBytecodeBundleResources::VT_TRIMESHES, trimeshes);
  }
  explicit RoutineBytecodeBundleResourcesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundleResources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundleResources>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UAVBundle>>> uavs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::BufferBundle>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TextureBundle>>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::TrimeshBundle>>> trimeshes = 0) {
  RoutineBytecodeBundleResourcesBuilder builder_(_fbb);
  builder_.add_trimeshes(trimeshes);
  builder_.add_textures(textures);
  builder_.add_buffers(buffers);
  builder_.add_uavs(uavs);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResourcesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::UAVBundle>> *uavs = nullptr,
    const std::vector<flatbuffers::Offset<Fx::BufferBundle>> *buffers = nullptr,
    const std::vector<flatbuffers::Offset<Fx::TextureBundle>> *textures = nullptr,
    const std::vector<flatbuffers::Offset<Fx::TrimeshBundle>> *trimeshes = nullptr) {
  auto uavs__ = uavs ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>>(*uavs) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<flatbuffers::Offset<Fx::BufferBundle>>(*buffers) : 0;
  auto textures__ = textures ? _fbb.CreateVector<flatbuffers::Offset<Fx::TextureBundle>>(*textures) : 0;
  auto trimeshes__ = trimeshes ? _fbb.CreateVector<flatbuffers::Offset<Fx::TrimeshBundle>>(*trimeshes) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      uavs__,
      buffers__,
      textures__,
      trimeshes__);
}

flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineBytecodeBundleT : public flatbuffers::NativeTable {
  typedef RoutineBytecodeBundle TableType;
  std::vector<uint8_t> code{};
  std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT> resources{};
  std::vector<uint32_t> numthreads{};
  RoutineBytecodeBundleT() = default;
  RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o);
  RoutineBytecodeBundleT(RoutineBytecodeBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineBytecodeBundleT &operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineBytecodeBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineBytecodeBundleT NativeTableType;
  typedef RoutineBytecodeBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_RESOURCES = 6,
    VT_NUMTHREADS = 8
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  const Fx::RoutineBytecodeBundleResources *resources() const {
    return GetPointer<const Fx::RoutineBytecodeBundleResources *>(VT_RESOURCES);
  }
  const flatbuffers::Vector<uint32_t> *numthreads() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NUMTHREADS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyVector(code()) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyTable(resources()) &&
           VerifyOffset(verifier, VT_NUMTHREADS) &&
           verifier.VerifyVector(numthreads()) &&
           verifier.EndTable();
  }
  RoutineBytecodeBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineBytecodeBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineBytecodeBundleBuilder {
  typedef RoutineBytecodeBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_CODE, code);
  }
  void add_resources(flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_RESOURCES, resources);
  }
  void add_numthreads(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads) {
    fbb_.AddOffset(RoutineBytecodeBundle::VT_NUMTHREADS, numthreads);
  }
  explicit RoutineBytecodeBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineBytecodeBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineBytecodeBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> numthreads = 0) {
  RoutineBytecodeBundleBuilder builder_(_fbb);
  builder_.add_numthreads(numthreads);
  builder_.add_resources(resources);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr,
    flatbuffers::Offset<Fx::RoutineBytecodeBundleResources> resources = 0,
    const std::vector<uint32_t> *numthreads = nullptr) {
  auto code__ = code ? _fbb.CreateVector<uint8_t>(*code) : 0;
  auto numthreads__ = numthreads ? _fbb.CreateVector<uint32_t>(*numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      code__,
      resources,
      numthreads__);
}

flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct Pass11BytecodeBundleT : public flatbuffers::NativeTable {
  typedef Pass11BytecodeBundle TableType;
  std::vector<uint8_t> code{};
};

struct Pass11BytecodeBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Pass11BytecodeBundleT NativeTableType;
  typedef Pass11BytecodeBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4
  };
  const flatbuffers::Vector<uint8_t> *code() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyVector(code()) &&
           verifier.EndTable();
  }
  Pass11BytecodeBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(Pass11BytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Pass11BytecodeBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pass11BytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct Pass11BytecodeBundleBuilder {
  typedef Pass11BytecodeBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code) {
    fbb_.AddOffset(Pass11BytecodeBundle::VT_CODE, code);
  }
  explicit Pass11BytecodeBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Pass11BytecodeBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pass11BytecodeBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pass11BytecodeBundle> CreatePass11BytecodeBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> code = 0) {
  Pass11BytecodeBundleBuilder builder_(_fbb);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pass11BytecodeBundle> CreatePass11BytecodeBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *code = nullptr) {
  auto code__ = code ? _fbb.CreateVector<uint8_t>(*code) : 0;
  return Fx::CreatePass11BytecodeBundle(
      _fbb,
      code__);
}

flatbuffers::Offset<Pass11BytecodeBundle> CreatePass11BytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const Pass11BytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineGLSLSourceBundleT : public flatbuffers::NativeTable {
  typedef RoutineGLSLSourceBundle TableType;
  std::string code{};
  std::vector<std::unique_ptr<Fx::GLSLAttributeT>> attributes{};
  std::vector<std::unique_ptr<Fx::CBBundleT>> cbuffers{};
  RoutineGLSLSourceBundleT() = default;
  RoutineGLSLSourceBundleT(const RoutineGLSLSourceBundleT &o);
  RoutineGLSLSourceBundleT(RoutineGLSLSourceBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineGLSLSourceBundleT &operator=(RoutineGLSLSourceBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineGLSLSourceBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineGLSLSourceBundleT NativeTableType;
  typedef RoutineGLSLSourceBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_ATTRIBUTES = 6,
    VT_CBUFFERS = 8
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>> *>(VT_ATTRIBUTES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>> *cbuffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>> *>(VT_CBUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           VerifyOffset(verifier, VT_CBUFFERS) &&
           verifier.VerifyVector(cbuffers()) &&
           verifier.VerifyVectorOfTables(cbuffers()) &&
           verifier.EndTable();
  }
  RoutineGLSLSourceBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineGLSLSourceBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineGLSLSourceBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLSourceBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineGLSLSourceBundleBuilder {
  typedef RoutineGLSLSourceBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(RoutineGLSLSourceBundle::VT_CODE, code);
  }
  void add_attributes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes) {
    fbb_.AddOffset(RoutineGLSLSourceBundle::VT_ATTRIBUTES, attributes);
  }
  void add_cbuffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>>> cbuffers) {
    fbb_.AddOffset(RoutineGLSLSourceBundle::VT_CBUFFERS, cbuffers);
  }
  explicit RoutineGLSLSourceBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineGLSLSourceBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineGLSLSourceBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineGLSLSourceBundle> CreateRoutineGLSLSourceBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::GLSLAttribute>>> attributes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>>> cbuffers = 0) {
  RoutineGLSLSourceBundleBuilder builder_(_fbb);
  builder_.add_cbuffers(cbuffers);
  builder_.add_attributes(attributes);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineGLSLSourceBundle> CreateRoutineGLSLSourceBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const std::vector<flatbuffers::Offset<Fx::GLSLAttribute>> *attributes = nullptr,
    const std::vector<flatbuffers::Offset<Fx::CBBundle>> *cbuffers = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto attributes__ = attributes ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>>(*attributes) : 0;
  auto cbuffers__ = cbuffers ? _fbb.CreateVector<flatbuffers::Offset<Fx::CBBundle>>(*cbuffers) : 0;
  return Fx::CreateRoutineGLSLSourceBundle(
      _fbb,
      code__,
      attributes__,
      cbuffers__);
}

flatbuffers::Offset<RoutineGLSLSourceBundle> CreateRoutineGLSLSourceBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLSourceBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineHLSLSourceBundleT : public flatbuffers::NativeTable {
  typedef RoutineHLSLSourceBundle TableType;
  std::string code{};
  std::string entryName{};
  std::vector<std::unique_ptr<Fx::CBBundleT>> cbuffers{};
  RoutineHLSLSourceBundleT() = default;
  RoutineHLSLSourceBundleT(const RoutineHLSLSourceBundleT &o);
  RoutineHLSLSourceBundleT(RoutineHLSLSourceBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  RoutineHLSLSourceBundleT &operator=(RoutineHLSLSourceBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct RoutineHLSLSourceBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineHLSLSourceBundleT NativeTableType;
  typedef RoutineHLSLSourceBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_ENTRYNAME = 6,
    VT_CBUFFERS = 8
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *entryName() const {
    return GetPointer<const flatbuffers::String *>(VT_ENTRYNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>> *cbuffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>> *>(VT_CBUFFERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.VerifyString(code()) &&
           VerifyOffset(verifier, VT_ENTRYNAME) &&
           verifier.VerifyString(entryName()) &&
           VerifyOffset(verifier, VT_CBUFFERS) &&
           verifier.VerifyVector(cbuffers()) &&
           verifier.VerifyVectorOfTables(cbuffers()) &&
           verifier.EndTable();
  }
  RoutineHLSLSourceBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineHLSLSourceBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineHLSLSourceBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineHLSLSourceBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineHLSLSourceBundleBuilder {
  typedef RoutineHLSLSourceBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(RoutineHLSLSourceBundle::VT_CODE, code);
  }
  void add_entryName(flatbuffers::Offset<flatbuffers::String> entryName) {
    fbb_.AddOffset(RoutineHLSLSourceBundle::VT_ENTRYNAME, entryName);
  }
  void add_cbuffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>>> cbuffers) {
    fbb_.AddOffset(RoutineHLSLSourceBundle::VT_CBUFFERS, cbuffers);
  }
  explicit RoutineHLSLSourceBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineHLSLSourceBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineHLSLSourceBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineHLSLSourceBundle> CreateRoutineHLSLSourceBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> entryName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::CBBundle>>> cbuffers = 0) {
  RoutineHLSLSourceBundleBuilder builder_(_fbb);
  builder_.add_cbuffers(cbuffers);
  builder_.add_entryName(entryName);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineHLSLSourceBundle> CreateRoutineHLSLSourceBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *entryName = nullptr,
    const std::vector<flatbuffers::Offset<Fx::CBBundle>> *cbuffers = nullptr) {
  auto code__ = code ? _fbb.CreateString(code) : 0;
  auto entryName__ = entryName ? _fbb.CreateString(entryName) : 0;
  auto cbuffers__ = cbuffers ? _fbb.CreateVector<flatbuffers::Offset<Fx::CBBundle>>(*cbuffers) : 0;
  return Fx::CreateRoutineHLSLSourceBundle(
      _fbb,
      code__,
      entryName__,
      cbuffers__);
}

flatbuffers::Offset<RoutineHLSLSourceBundle> CreateRoutineHLSLSourceBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineHLSLSourceBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RoutineShaderBundleT : public flatbuffers::NativeTable {
  typedef RoutineShaderBundle TableType;
  std::vector<Fx::RoutineSourceBundleUnion> shaders{};
};

struct RoutineShaderBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoutineShaderBundleT NativeTableType;
  typedef RoutineShaderBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHADERS_TYPE = 4,
    VT_SHADERS = 6
  };
  const flatbuffers::Vector<uint8_t> *shaders_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SHADERS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *shaders() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_SHADERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHADERS_TYPE) &&
           verifier.VerifyVector(shaders_type()) &&
           VerifyOffset(verifier, VT_SHADERS) &&
           verifier.VerifyVector(shaders()) &&
           VerifyRoutineSourceBundleVector(verifier, shaders(), shaders_type()) &&
           verifier.EndTable();
  }
  RoutineShaderBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RoutineShaderBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RoutineShaderBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineShaderBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RoutineShaderBundleBuilder {
  typedef RoutineShaderBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shaders_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> shaders_type) {
    fbb_.AddOffset(RoutineShaderBundle::VT_SHADERS_TYPE, shaders_type);
  }
  void add_shaders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> shaders) {
    fbb_.AddOffset(RoutineShaderBundle::VT_SHADERS, shaders);
  }
  explicit RoutineShaderBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RoutineShaderBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RoutineShaderBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<RoutineShaderBundle> CreateRoutineShaderBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> shaders_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> shaders = 0) {
  RoutineShaderBundleBuilder builder_(_fbb);
  builder_.add_shaders(shaders);
  builder_.add_shaders_type(shaders_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RoutineShaderBundle> CreateRoutineShaderBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *shaders_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *shaders = nullptr) {
  auto shaders_type__ = shaders_type ? _fbb.CreateVector<uint8_t>(*shaders_type) : 0;
  auto shaders__ = shaders ? _fbb.CreateVector<flatbuffers::Offset<void>>(*shaders) : 0;
  return Fx::CreateRoutineShaderBundle(
      _fbb,
      shaders_type__,
      shaders__);
}

flatbuffers::Offset<RoutineShaderBundle> CreateRoutineShaderBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineShaderBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartRenderPassT : public flatbuffers::NativeTable {
  typedef PartRenderPass TableType;
  std::vector<Fx::RoutineBundleUnion> routines{};
  std::string geometry{};
  bool sorting = false;
  uint32_t instanceCount = 0;
  uint32_t stride = 0;
  std::unique_ptr<Fx::TypeLayoutT> instance{};
  std::vector<std::unique_ptr<Fx::RenderStateT>> renderStates{};
  PartRenderPassT() = default;
  PartRenderPassT(const PartRenderPassT &o);
  PartRenderPassT(PartRenderPassT&&) FLATBUFFERS_NOEXCEPT = default;
  PartRenderPassT &operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT;
};

struct PartRenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartRenderPassT NativeTableType;
  typedef PartRenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTINES_TYPE = 4,
    VT_ROUTINES = 6,
    VT_GEOMETRY = 8,
    VT_SORTING = 10,
    VT_INSTANCECOUNT = 12,
    VT_STRIDE = 14,
    VT_INSTANCE = 16,
    VT_RENDERSTATES = 18
  };
  const flatbuffers::Vector<uint8_t> *routines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *routines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ROUTINES);
  }
  const flatbuffers::String *geometry() const {
    return GetPointer<const flatbuffers::String *>(VT_GEOMETRY);
  }
  bool sorting() const {
    return GetField<uint8_t>(VT_SORTING, 0) != 0;
  }
  uint32_t instanceCount() const {
    return GetField<uint32_t>(VT_INSTANCECOUNT, 0);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const Fx::TypeLayout *instance() const {
    return GetPointer<const Fx::TypeLayout *>(VT_INSTANCE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>> *renderStates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>> *>(VT_RENDERSTATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTINES_TYPE) &&
           verifier.VerifyVector(routines_type()) &&
           VerifyOffset(verifier, VT_ROUTINES) &&
           verifier.VerifyVector(routines()) &&
           VerifyRoutineBundleVector(verifier, routines(), routines_type()) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           verifier.VerifyString(geometry()) &&
           VerifyField<uint8_t>(verifier, VT_SORTING, 1) &&
           VerifyField<uint32_t>(verifier, VT_INSTANCECOUNT, 4) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyOffset(verifier, VT_RENDERSTATES) &&
           verifier.VerifyVector(renderStates()) &&
           verifier.VerifyVectorOfTables(renderStates()) &&
           verifier.EndTable();
  }
  PartRenderPassT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartRenderPass> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartRenderPassBuilder {
  typedef PartRenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES_TYPE, routines_type);
  }
  void add_routines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines) {
    fbb_.AddOffset(PartRenderPass::VT_ROUTINES, routines);
  }
  void add_geometry(flatbuffers::Offset<flatbuffers::String> geometry) {
    fbb_.AddOffset(PartRenderPass::VT_GEOMETRY, geometry);
  }
  void add_sorting(bool sorting) {
    fbb_.AddElement<uint8_t>(PartRenderPass::VT_SORTING, static_cast<uint8_t>(sorting), 0);
  }
  void add_instanceCount(uint32_t instanceCount) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_INSTANCECOUNT, instanceCount, 0);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(PartRenderPass::VT_STRIDE, stride, 0);
  }
  void add_instance(flatbuffers::Offset<Fx::TypeLayout> instance) {
    fbb_.AddOffset(PartRenderPass::VT_INSTANCE, instance);
  }
  void add_renderStates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>>> renderStates) {
    fbb_.AddOffset(PartRenderPass::VT_RENDERSTATES, renderStates);
  }
  explicit PartRenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartRenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartRenderPass>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines = 0,
    flatbuffers::Offset<flatbuffers::String> geometry = 0,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>>> renderStates = 0) {
  PartRenderPassBuilder builder_(_fbb);
  builder_.add_renderStates(renderStates);
  builder_.add_instance(instance);
  builder_.add_stride(stride);
  builder_.add_instanceCount(instanceCount);
  builder_.add_geometry(geometry);
  builder_.add_routines(routines);
  builder_.add_routines_type(routines_type);
  builder_.add_sorting(sorting);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *routines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *routines = nullptr,
    const char *geometry = nullptr,
    bool sorting = false,
    uint32_t instanceCount = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0,
    const std::vector<flatbuffers::Offset<Fx::RenderState>> *renderStates = nullptr) {
  auto routines_type__ = routines_type ? _fbb.CreateVector<uint8_t>(*routines_type) : 0;
  auto routines__ = routines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*routines) : 0;
  auto geometry__ = geometry ? _fbb.CreateString(geometry) : 0;
  auto renderStates__ = renderStates ? _fbb.CreateVector<flatbuffers::Offset<Fx::RenderState>>(*renderStates) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      routines_type__,
      routines__,
      geometry__,
      sorting,
      instanceCount,
      stride,
      instance,
      renderStates__);
}

flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartBundleT : public flatbuffers::NativeTable {
  typedef PartBundle TableType;
  uint32_t capacity = 0;
  std::vector<Fx::RoutineBundleUnion> simulationRoutines{};
  std::vector<std::unique_ptr<Fx::PartRenderPassT>> renderPasses{};
  std::unique_ptr<Fx::TypeLayoutT> particle{};
  PartBundleT() = default;
  PartBundleT(const PartBundleT &o);
  PartBundleT(PartBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  PartBundleT &operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct PartBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartBundleT NativeTableType;
  typedef PartBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CAPACITY = 4,
    VT_SIMULATIONROUTINES_TYPE = 6,
    VT_SIMULATIONROUTINES = 8,
    VT_RENDERPASSES = 10,
    VT_PARTICLE = 12
  };
  uint32_t capacity() const {
    return GetField<uint32_t>(VT_CAPACITY, 0);
  }
  const flatbuffers::Vector<uint8_t> *simulationRoutines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SIMULATIONROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *simulationRoutines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_SIMULATIONROUTINES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>> *>(VT_RENDERPASSES);
  }
  const Fx::TypeLayout *particle() const {
    return GetPointer<const Fx::TypeLayout *>(VT_PARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_CAPACITY, 4) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES_TYPE) &&
           verifier.VerifyVector(simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_SIMULATIONROUTINES) &&
           verifier.VerifyVector(simulationRoutines()) &&
           VerifyRoutineBundleVector(verifier, simulationRoutines(), simulationRoutines_type()) &&
           VerifyOffset(verifier, VT_RENDERPASSES) &&
           verifier.VerifyVector(renderPasses()) &&
           verifier.VerifyVectorOfTables(renderPasses()) &&
           VerifyOffset(verifier, VT_PARTICLE) &&
           verifier.VerifyTable(particle()) &&
           verifier.EndTable();
  }
  PartBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartBundleBuilder {
  typedef PartBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_capacity(uint32_t capacity) {
    fbb_.AddElement<uint32_t>(PartBundle::VT_CAPACITY, capacity, 0);
  }
  void add_simulationRoutines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES_TYPE, simulationRoutines_type);
  }
  void add_simulationRoutines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines) {
    fbb_.AddOffset(PartBundle::VT_SIMULATIONROUTINES, simulationRoutines);
  }
  void add_renderPasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses) {
    fbb_.AddOffset(PartBundle::VT_RENDERPASSES, renderPasses);
  }
  void add_particle(flatbuffers::Offset<Fx::TypeLayout> particle) {
    fbb_.AddOffset(PartBundle::VT_PARTICLE, particle);
  }
  explicit PartBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartBundle> CreatePartBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> simulationRoutines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> simulationRoutines = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PartRenderPass>>> renderPasses = 0,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  PartBundleBuilder builder_(_fbb);
  builder_.add_particle(particle);
  builder_.add_renderPasses(renderPasses);
  builder_.add_simulationRoutines(simulationRoutines);
  builder_.add_simulationRoutines_type(simulationRoutines_type);
  builder_.add_capacity(capacity);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartBundle> CreatePartBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t capacity = 0,
    const std::vector<uint8_t> *simulationRoutines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *simulationRoutines = nullptr,
    const std::vector<flatbuffers::Offset<Fx::PartRenderPass>> *renderPasses = nullptr,
    flatbuffers::Offset<Fx::TypeLayout> particle = 0) {
  auto simulationRoutines_type__ = simulationRoutines_type ? _fbb.CreateVector<uint8_t>(*simulationRoutines_type) : 0;
  auto simulationRoutines__ = simulationRoutines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*simulationRoutines) : 0;
  auto renderPasses__ = renderPasses ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>>(*renderPasses) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      capacity,
      simulationRoutines_type__,
      simulationRoutines__,
      renderPasses__,
      particle);
}

flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RenderStateT : public flatbuffers::NativeTable {
  typedef RenderState TableType;
  uint32_t type = 0;
  uint32_t value = 0;
};

struct RenderState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderStateT NativeTableType;
  typedef RenderStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  uint32_t type() const {
    return GetField<uint32_t>(VT_TYPE, 0);
  }
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
  RenderStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RenderStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RenderState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RenderStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RenderStateBuilder {
  typedef RenderState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint32_t type) {
    fbb_.AddElement<uint32_t>(RenderState::VT_TYPE, type, 0);
  }
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(RenderState::VT_VALUE, value, 0);
  }
  explicit RenderStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderState>(end);
    return o;
  }
};

inline flatbuffers::Offset<RenderState> CreateRenderState(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t type = 0,
    uint32_t value = 0) {
  RenderStateBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<RenderState> CreateRenderState(flatbuffers::FlatBufferBuilder &_fbb, const RenderStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatRenderPassT : public flatbuffers::NativeTable {
  typedef MatRenderPass TableType;
  std::vector<Fx::RoutineBundleUnion> routines{};
  std::unique_ptr<Fx::TypeLayoutT> instance{};
  uint32_t stride = 0;
  std::vector<std::unique_ptr<Fx::RenderStateT>> renderStates{};
  MatRenderPassT() = default;
  MatRenderPassT(const MatRenderPassT &o);
  MatRenderPassT(MatRenderPassT&&) FLATBUFFERS_NOEXCEPT = default;
  MatRenderPassT &operator=(MatRenderPassT o) FLATBUFFERS_NOEXCEPT;
};

struct MatRenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatRenderPassT NativeTableType;
  typedef MatRenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROUTINES_TYPE = 4,
    VT_ROUTINES = 6,
    VT_INSTANCE = 8,
    VT_STRIDE = 10,
    VT_RENDERSTATES = 12
  };
  const flatbuffers::Vector<uint8_t> *routines_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ROUTINES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *routines() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ROUTINES);
  }
  const Fx::TypeLayout *instance() const {
    return GetPointer<const Fx::TypeLayout *>(VT_INSTANCE);
  }
  uint32_t stride() const {
    return GetField<uint32_t>(VT_STRIDE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>> *renderStates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>> *>(VT_RENDERSTATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROUTINES_TYPE) &&
           verifier.VerifyVector(routines_type()) &&
           VerifyOffset(verifier, VT_ROUTINES) &&
           verifier.VerifyVector(routines()) &&
           VerifyRoutineBundleVector(verifier, routines(), routines_type()) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyField<uint32_t>(verifier, VT_STRIDE, 4) &&
           VerifyOffset(verifier, VT_RENDERSTATES) &&
           verifier.VerifyVector(renderStates()) &&
           verifier.VerifyVectorOfTables(renderStates()) &&
           verifier.EndTable();
  }
  MatRenderPassT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatRenderPass> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatRenderPassBuilder {
  typedef MatRenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_routines_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type) {
    fbb_.AddOffset(MatRenderPass::VT_ROUTINES_TYPE, routines_type);
  }
  void add_routines(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines) {
    fbb_.AddOffset(MatRenderPass::VT_ROUTINES, routines);
  }
  void add_instance(flatbuffers::Offset<Fx::TypeLayout> instance) {
    fbb_.AddOffset(MatRenderPass::VT_INSTANCE, instance);
  }
  void add_stride(uint32_t stride) {
    fbb_.AddElement<uint32_t>(MatRenderPass::VT_STRIDE, stride, 0);
  }
  void add_renderStates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>>> renderStates) {
    fbb_.AddOffset(MatRenderPass::VT_RENDERSTATES, renderStates);
  }
  explicit MatRenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatRenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatRenderPass>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> routines_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> routines = 0,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0,
    uint32_t stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::RenderState>>> renderStates = 0) {
  MatRenderPassBuilder builder_(_fbb);
  builder_.add_renderStates(renderStates);
  builder_.add_stride(stride);
  builder_.add_instance(instance);
  builder_.add_routines(routines);
  builder_.add_routines_type(routines_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *routines_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *routines = nullptr,
    flatbuffers::Offset<Fx::TypeLayout> instance = 0,
    uint32_t stride = 0,
    const std::vector<flatbuffers::Offset<Fx::RenderState>> *renderStates = nullptr) {
  auto routines_type__ = routines_type ? _fbb.CreateVector<uint8_t>(*routines_type) : 0;
  auto routines__ = routines ? _fbb.CreateVector<flatbuffers::Offset<void>>(*routines) : 0;
  auto renderStates__ = renderStates ? _fbb.CreateVector<flatbuffers::Offset<Fx::RenderState>>(*renderStates) : 0;
  return Fx::CreateMatRenderPass(
      _fbb,
      routines_type__,
      routines__,
      instance,
      stride,
      renderStates__);
}

flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MatBundleT : public flatbuffers::NativeTable {
  typedef MatBundle TableType;
  std::vector<std::unique_ptr<Fx::MatRenderPassT>> renderPasses{};
  MatBundleT() = default;
  MatBundleT(const MatBundleT &o);
  MatBundleT(MatBundleT&&) FLATBUFFERS_NOEXCEPT = default;
  MatBundleT &operator=(MatBundleT o) FLATBUFFERS_NOEXCEPT;
};

struct MatBundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatBundleT NativeTableType;
  typedef MatBundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RENDERPASSES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>> *renderPasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>> *>(VT_RENDERPASSES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RENDERPASSES) &&
           verifier.VerifyVector(renderPasses()) &&
           verifier.VerifyVectorOfTables(renderPasses()) &&
           verifier.EndTable();
  }
  MatBundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MatBundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MatBundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MatBundleBuilder {
  typedef MatBundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_renderPasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>>> renderPasses) {
    fbb_.AddOffset(MatBundle::VT_RENDERPASSES, renderPasses);
  }
  explicit MatBundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatBundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatBundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatBundle> CreateMatBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::MatRenderPass>>> renderPasses = 0) {
  MatBundleBuilder builder_(_fbb);
  builder_.add_renderPasses(renderPasses);
  return builder_.Finish();
}

inline flatbuffers::Offset<MatBundle> CreateMatBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::MatRenderPass>> *renderPasses = nullptr) {
  auto renderPasses__ = renderPasses ? _fbb.CreateVector<flatbuffers::Offset<Fx::MatRenderPass>>(*renderPasses) : 0;
  return Fx::CreateMatBundle(
      _fbb,
      renderPasses__);
}

flatbuffers::Offset<MatBundle> CreateMatBundle(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringValueT : public flatbuffers::NativeTable {
  typedef StringValue TableType;
  std::string value{};
};

struct StringValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringValueT NativeTableType;
  typedef StringValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  StringValueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringValueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StringValue> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringValueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringValueBuilder {
  typedef StringValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringValue::VT_VALUE, value);
  }
  explicit StringValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StringValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringValue> CreateStringValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringValue> CreateStringValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Fx::CreateStringValue(
      _fbb,
      value__);
}

flatbuffers::Offset<StringValue> CreateStringValue(flatbuffers::FlatBufferBuilder &_fbb, const StringValueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TextureValueT : public flatbuffers::NativeTable {
  typedef TextureValue TableType;
  std::string value{};
};

struct TextureValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextureValueT NativeTableType;
  typedef TextureValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  TextureValueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TextureValueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TextureValue> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureValueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TextureValueBuilder {
  typedef TextureValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(TextureValue::VT_VALUE, value);
  }
  explicit TextureValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TextureValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextureValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextureValue> CreateTextureValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  TextureValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextureValue> CreateTextureValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Fx::CreateTextureValue(
      _fbb,
      value__);
}

flatbuffers::Offset<TextureValue> CreateTextureValue(flatbuffers::FlatBufferBuilder &_fbb, const TextureValueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshValueT : public flatbuffers::NativeTable {
  typedef MeshValue TableType;
  std::string value{};
};

struct MeshValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshValueT NativeTableType;
  typedef MeshValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  MeshValueT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshValueT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshValue> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshValueT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshValueBuilder {
  typedef MeshValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(MeshValue::VT_VALUE, value);
  }
  explicit MeshValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeshValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshValue>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshValue> CreateMeshValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  MeshValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshValue> CreateMeshValueDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Fx::CreateMeshValue(
      _fbb,
      value__);
}

flatbuffers::Offset<MeshValue> CreateMeshValue(flatbuffers::FlatBufferBuilder &_fbb, const MeshValueT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ViewTypePropertyT : public flatbuffers::NativeTable {
  typedef ViewTypeProperty TableType;
  std::string name{};
  Fx::PropertyValueUnion value{};
};

struct ViewTypeProperty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ViewTypePropertyT NativeTableType;
  typedef ViewTypePropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Fx::PropertyValue value_type() const {
    return static_cast<Fx::PropertyValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Fx::UintValue *value_as_UintValue() const {
    return value_type() == Fx::PropertyValue_UintValue ? static_cast<const Fx::UintValue *>(value()) : nullptr;
  }
  const Fx::IntValue *value_as_IntValue() const {
    return value_type() == Fx::PropertyValue_IntValue ? static_cast<const Fx::IntValue *>(value()) : nullptr;
  }
  const Fx::FloatValue *value_as_FloatValue() const {
    return value_type() == Fx::PropertyValue_FloatValue ? static_cast<const Fx::FloatValue *>(value()) : nullptr;
  }
  const Fx::StringValue *value_as_StringValue() const {
    return value_type() == Fx::PropertyValue_StringValue ? static_cast<const Fx::StringValue *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPropertyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  ViewTypePropertyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ViewTypePropertyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ViewTypeProperty> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewTypePropertyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::UintValue *ViewTypeProperty::value_as<Fx::UintValue>() const {
  return value_as_UintValue();
}

template<> inline const Fx::IntValue *ViewTypeProperty::value_as<Fx::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const Fx::FloatValue *ViewTypeProperty::value_as<Fx::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const Fx::StringValue *ViewTypeProperty::value_as<Fx::StringValue>() const {
  return value_as_StringValue();
}

struct ViewTypePropertyBuilder {
  typedef ViewTypeProperty Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ViewTypeProperty::VT_NAME, name);
  }
  void add_value_type(Fx::PropertyValue value_type) {
    fbb_.AddElement<uint8_t>(ViewTypeProperty::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(ViewTypeProperty::VT_VALUE, value);
  }
  explicit ViewTypePropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ViewTypeProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ViewTypeProperty>(end);
    return o;
  }
};

inline flatbuffers::Offset<ViewTypeProperty> CreateViewTypeProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Fx::PropertyValue value_type = Fx::PropertyValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  ViewTypePropertyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ViewTypeProperty> CreateViewTypePropertyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Fx::PropertyValue value_type = Fx::PropertyValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreateViewTypeProperty(
      _fbb,
      name__,
      value_type,
      value);
}

flatbuffers::Offset<ViewTypeProperty> CreateViewTypeProperty(flatbuffers::FlatBufferBuilder &_fbb, const ViewTypePropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UIControlT : public flatbuffers::NativeTable {
  typedef UIControl TableType;
  std::string name{};
  Fx::ControlValueUnion value{};
  std::vector<std::unique_ptr<Fx::ViewTypePropertyT>> properties{};
  UIControlT() = default;
  UIControlT(const UIControlT &o);
  UIControlT(UIControlT&&) FLATBUFFERS_NOEXCEPT = default;
  UIControlT &operator=(UIControlT o) FLATBUFFERS_NOEXCEPT;
};

struct UIControl FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UIControlT NativeTableType;
  typedef UIControlBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_PROPERTIES = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Fx::ControlValue value_type() const {
    return static_cast<Fx::ControlValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Fx::UintValue *value_as_UintValue() const {
    return value_type() == Fx::ControlValue_UintValue ? static_cast<const Fx::UintValue *>(value()) : nullptr;
  }
  const Fx::IntValue *value_as_IntValue() const {
    return value_type() == Fx::ControlValue_IntValue ? static_cast<const Fx::IntValue *>(value()) : nullptr;
  }
  const Fx::FloatValue *value_as_FloatValue() const {
    return value_type() == Fx::ControlValue_FloatValue ? static_cast<const Fx::FloatValue *>(value()) : nullptr;
  }
  const Fx::Float2Value *value_as_Float2Value() const {
    return value_type() == Fx::ControlValue_Float2Value ? static_cast<const Fx::Float2Value *>(value()) : nullptr;
  }
  const Fx::Float3Value *value_as_Float3Value() const {
    return value_type() == Fx::ControlValue_Float3Value ? static_cast<const Fx::Float3Value *>(value()) : nullptr;
  }
  const Fx::Float4Value *value_as_Float4Value() const {
    return value_type() == Fx::ControlValue_Float4Value ? static_cast<const Fx::Float4Value *>(value()) : nullptr;
  }
  const Fx::ColorValue *value_as_ColorValue() const {
    return value_type() == Fx::ControlValue_ColorValue ? static_cast<const Fx::ColorValue *>(value()) : nullptr;
  }
  const Fx::TextureValue *value_as_TextureValue() const {
    return value_type() == Fx::ControlValue_TextureValue ? static_cast<const Fx::TextureValue *>(value()) : nullptr;
  }
  const Fx::MeshValue *value_as_MeshValue() const {
    return value_type() == Fx::ControlValue_MeshValue ? static_cast<const Fx::MeshValue *>(value()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::ViewTypeProperty>> *properties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::ViewTypeProperty>> *>(VT_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyControlValue(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
  UIControlT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UIControlT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UIControl> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::UintValue *UIControl::value_as<Fx::UintValue>() const {
  return value_as_UintValue();
}

template<> inline const Fx::IntValue *UIControl::value_as<Fx::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const Fx::FloatValue *UIControl::value_as<Fx::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const Fx::Float2Value *UIControl::value_as<Fx::Float2Value>() const {
  return value_as_Float2Value();
}

template<> inline const Fx::Float3Value *UIControl::value_as<Fx::Float3Value>() const {
  return value_as_Float3Value();
}

template<> inline const Fx::Float4Value *UIControl::value_as<Fx::Float4Value>() const {
  return value_as_Float4Value();
}

template<> inline const Fx::ColorValue *UIControl::value_as<Fx::ColorValue>() const {
  return value_as_ColorValue();
}

template<> inline const Fx::TextureValue *UIControl::value_as<Fx::TextureValue>() const {
  return value_as_TextureValue();
}

template<> inline const Fx::MeshValue *UIControl::value_as<Fx::MeshValue>() const {
  return value_as_MeshValue();
}

struct UIControlBuilder {
  typedef UIControl Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(UIControl::VT_NAME, name);
  }
  void add_value_type(Fx::ControlValue value_type) {
    fbb_.AddElement<uint8_t>(UIControl::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(UIControl::VT_VALUE, value);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::ViewTypeProperty>>> properties) {
    fbb_.AddOffset(UIControl::VT_PROPERTIES, properties);
  }
  explicit UIControlBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UIControl> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UIControl>(end);
    return o;
  }
};

inline flatbuffers::Offset<UIControl> CreateUIControl(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Fx::ControlValue value_type = Fx::ControlValue_NONE,
    flatbuffers::Offset<void> value = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::ViewTypeProperty>>> properties = 0) {
  UIControlBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<UIControl> CreateUIControlDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Fx::ControlValue value_type = Fx::ControlValue_NONE,
    flatbuffers::Offset<void> value = 0,
    const std::vector<flatbuffers::Offset<Fx::ViewTypeProperty>> *properties = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto properties__ = properties ? _fbb.CreateVector<flatbuffers::Offset<Fx::ViewTypeProperty>>(*properties) : 0;
  return Fx::CreateUIControl(
      _fbb,
      name__,
      value_type,
      value,
      properties__);
}

flatbuffers::Offset<UIControl> CreateUIControl(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PresetEntryT : public flatbuffers::NativeTable {
  typedef PresetEntry TableType;
  std::string name{};
  Fx::ControlValueUnion value{};
};

struct PresetEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PresetEntryT NativeTableType;
  typedef PresetEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  Fx::ControlValue value_type() const {
    return static_cast<Fx::ControlValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Fx::UintValue *value_as_UintValue() const {
    return value_type() == Fx::ControlValue_UintValue ? static_cast<const Fx::UintValue *>(value()) : nullptr;
  }
  const Fx::IntValue *value_as_IntValue() const {
    return value_type() == Fx::ControlValue_IntValue ? static_cast<const Fx::IntValue *>(value()) : nullptr;
  }
  const Fx::FloatValue *value_as_FloatValue() const {
    return value_type() == Fx::ControlValue_FloatValue ? static_cast<const Fx::FloatValue *>(value()) : nullptr;
  }
  const Fx::Float2Value *value_as_Float2Value() const {
    return value_type() == Fx::ControlValue_Float2Value ? static_cast<const Fx::Float2Value *>(value()) : nullptr;
  }
  const Fx::Float3Value *value_as_Float3Value() const {
    return value_type() == Fx::ControlValue_Float3Value ? static_cast<const Fx::Float3Value *>(value()) : nullptr;
  }
  const Fx::Float4Value *value_as_Float4Value() const {
    return value_type() == Fx::ControlValue_Float4Value ? static_cast<const Fx::Float4Value *>(value()) : nullptr;
  }
  const Fx::ColorValue *value_as_ColorValue() const {
    return value_type() == Fx::ControlValue_ColorValue ? static_cast<const Fx::ColorValue *>(value()) : nullptr;
  }
  const Fx::TextureValue *value_as_TextureValue() const {
    return value_type() == Fx::ControlValue_TextureValue ? static_cast<const Fx::TextureValue *>(value()) : nullptr;
  }
  const Fx::MeshValue *value_as_MeshValue() const {
    return value_type() == Fx::ControlValue_MeshValue ? static_cast<const Fx::MeshValue *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyControlValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  PresetEntryT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PresetEntryT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PresetEntry> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::UintValue *PresetEntry::value_as<Fx::UintValue>() const {
  return value_as_UintValue();
}

template<> inline const Fx::IntValue *PresetEntry::value_as<Fx::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const Fx::FloatValue *PresetEntry::value_as<Fx::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const Fx::Float2Value *PresetEntry::value_as<Fx::Float2Value>() const {
  return value_as_Float2Value();
}

template<> inline const Fx::Float3Value *PresetEntry::value_as<Fx::Float3Value>() const {
  return value_as_Float3Value();
}

template<> inline const Fx::Float4Value *PresetEntry::value_as<Fx::Float4Value>() const {
  return value_as_Float4Value();
}

template<> inline const Fx::ColorValue *PresetEntry::value_as<Fx::ColorValue>() const {
  return value_as_ColorValue();
}

template<> inline const Fx::TextureValue *PresetEntry::value_as<Fx::TextureValue>() const {
  return value_as_TextureValue();
}

template<> inline const Fx::MeshValue *PresetEntry::value_as<Fx::MeshValue>() const {
  return value_as_MeshValue();
}

struct PresetEntryBuilder {
  typedef PresetEntry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PresetEntry::VT_NAME, name);
  }
  void add_value_type(Fx::ControlValue value_type) {
    fbb_.AddElement<uint8_t>(PresetEntry::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(PresetEntry::VT_VALUE, value);
  }
  explicit PresetEntryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PresetEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PresetEntry>(end);
    return o;
  }
};

inline flatbuffers::Offset<PresetEntry> CreatePresetEntry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    Fx::ControlValue value_type = Fx::ControlValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  PresetEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PresetEntry> CreatePresetEntryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    Fx::ControlValue value_type = Fx::ControlValue_NONE,
    flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Fx::CreatePresetEntry(
      _fbb,
      name__,
      value_type,
      value);
}

flatbuffers::Offset<PresetEntry> CreatePresetEntry(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PresetT : public flatbuffers::NativeTable {
  typedef Preset TableType;
  std::string name{};
  std::string desc{};
  std::vector<std::unique_ptr<Fx::PresetEntryT>> data{};
  PresetT() = default;
  PresetT(const PresetT &o);
  PresetT(PresetT&&) FLATBUFFERS_NOEXCEPT = default;
  PresetT &operator=(PresetT o) FLATBUFFERS_NOEXCEPT;
};

struct Preset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PresetT NativeTableType;
  typedef PresetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESC = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyString(desc()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  PresetT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PresetT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Preset> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PresetBuilder {
  typedef Preset Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Preset::VT_NAME, name);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(Preset::VT_DESC, desc);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>>> data) {
    fbb_.AddOffset(Preset::VT_DATA, data);
  }
  explicit PresetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Preset> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Preset>(end);
    return o;
  }
};

inline flatbuffers::Offset<Preset> CreatePreset(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::PresetEntry>>> data = 0) {
  PresetBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_desc(desc);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Preset> CreatePresetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *desc = nullptr,
    const std::vector<flatbuffers::Offset<Fx::PresetEntry>> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto desc__ = desc ? _fbb.CreateString(desc) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<Fx::PresetEntry>>(*data) : 0;
  return Fx::CreatePreset(
      _fbb,
      name__,
      desc__,
      data__);
}

flatbuffers::Offset<Preset> CreatePreset(flatbuffers::FlatBufferBuilder &_fbb, const PresetT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleT : public flatbuffers::NativeTable {
  typedef Bundle TableType;
  std::string name{};
  std::unique_ptr<Fx::BundleSignatureT> signature{};
  std::unique_ptr<Fx::BundleMetaT> meta{};
  Fx::BundleContentUnion content{};
  std::vector<std::unique_ptr<Fx::UIControlT>> controls{};
  std::vector<std::unique_ptr<Fx::PresetT>> presets{};
  BundleT() = default;
  BundleT(const BundleT &o);
  BundleT(BundleT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleT &operator=(BundleT o) FLATBUFFERS_NOEXCEPT;
};

struct Bundle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleT NativeTableType;
  typedef BundleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIGNATURE = 6,
    VT_META = 8,
    VT_CONTENT_TYPE = 10,
    VT_CONTENT = 12,
    VT_CONTROLS = 14,
    VT_PRESETS = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Fx::BundleSignature *signature() const {
    return GetPointer<const Fx::BundleSignature *>(VT_SIGNATURE);
  }
  const Fx::BundleMeta *meta() const {
    return GetPointer<const Fx::BundleMeta *>(VT_META);
  }
  Fx::BundleContent content_type() const {
    return static_cast<Fx::BundleContent>(GetField<uint8_t>(VT_CONTENT_TYPE, 0));
  }
  const void *content() const {
    return GetPointer<const void *>(VT_CONTENT);
  }
  template<typename T> const T *content_as() const;
  const Fx::PartBundle *content_as_PartBundle() const {
    return content_type() == Fx::BundleContent_PartBundle ? static_cast<const Fx::PartBundle *>(content()) : nullptr;
  }
  const Fx::MatBundle *content_as_MatBundle() const {
    return content_type() == Fx::BundleContent_MatBundle ? static_cast<const Fx::MatBundle *>(content()) : nullptr;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>> *controls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>> *>(VT_CONTROLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>> *presets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>> *>(VT_PRESETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIGNATURE) &&
           verifier.VerifyTable(signature()) &&
           VerifyOffset(verifier, VT_META) &&
           verifier.VerifyTable(meta()) &&
           VerifyField<uint8_t>(verifier, VT_CONTENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           VerifyBundleContent(verifier, content(), content_type()) &&
           VerifyOffset(verifier, VT_CONTROLS) &&
           verifier.VerifyVector(controls()) &&
           verifier.VerifyVectorOfTables(controls()) &&
           VerifyOffset(verifier, VT_PRESETS) &&
           verifier.VerifyVector(presets()) &&
           verifier.VerifyVectorOfTables(presets()) &&
           verifier.EndTable();
  }
  BundleT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Bundle> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Fx::PartBundle *Bundle::content_as<Fx::PartBundle>() const {
  return content_as_PartBundle();
}

template<> inline const Fx::MatBundle *Bundle::content_as<Fx::MatBundle>() const {
  return content_as_MatBundle();
}

struct BundleBuilder {
  typedef Bundle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Bundle::VT_NAME, name);
  }
  void add_signature(flatbuffers::Offset<Fx::BundleSignature> signature) {
    fbb_.AddOffset(Bundle::VT_SIGNATURE, signature);
  }
  void add_meta(flatbuffers::Offset<Fx::BundleMeta> meta) {
    fbb_.AddOffset(Bundle::VT_META, meta);
  }
  void add_content_type(Fx::BundleContent content_type) {
    fbb_.AddElement<uint8_t>(Bundle::VT_CONTENT_TYPE, static_cast<uint8_t>(content_type), 0);
  }
  void add_content(flatbuffers::Offset<void> content) {
    fbb_.AddOffset(Bundle::VT_CONTENT, content);
  }
  void add_controls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>>> controls) {
    fbb_.AddOffset(Bundle::VT_CONTROLS, controls);
  }
  void add_presets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>>> presets) {
    fbb_.AddOffset(Bundle::VT_PRESETS, presets);
  }
  explicit BundleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Bundle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bundle>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bundle> CreateBundle(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    flatbuffers::Offset<Fx::BundleMeta> meta = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::UIControl>>> controls = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Preset>>> presets = 0) {
  BundleBuilder builder_(_fbb);
  builder_.add_presets(presets);
  builder_.add_controls(controls);
  builder_.add_content(content);
  builder_.add_meta(meta);
  builder_.add_signature(signature);
  builder_.add_name(name);
  builder_.add_content_type(content_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Bundle> CreateBundleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Fx::BundleSignature> signature = 0,
    flatbuffers::Offset<Fx::BundleMeta> meta = 0,
    Fx::BundleContent content_type = Fx::BundleContent_NONE,
    flatbuffers::Offset<void> content = 0,
    const std::vector<flatbuffers::Offset<Fx::UIControl>> *controls = nullptr,
    const std::vector<flatbuffers::Offset<Fx::Preset>> *presets = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto controls__ = controls ? _fbb.CreateVector<flatbuffers::Offset<Fx::UIControl>>(*controls) : 0;
  auto presets__ = presets ? _fbb.CreateVector<flatbuffers::Offset<Fx::Preset>>(*presets) : 0;
  return Fx::CreateBundle(
      _fbb,
      name__,
      signature,
      meta,
      content_type,
      content,
      controls__,
      presets__);
}

flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BundleCollectionT : public flatbuffers::NativeTable {
  typedef BundleCollection TableType;
  std::vector<std::unique_ptr<Fx::BundleT>> content{};
  BundleCollectionT() = default;
  BundleCollectionT(const BundleCollectionT &o);
  BundleCollectionT(BundleCollectionT&&) FLATBUFFERS_NOEXCEPT = default;
  BundleCollectionT &operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT;
};

struct BundleCollection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BundleCollectionT NativeTableType;
  typedef BundleCollectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTENT = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *content() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>> *>(VT_CONTENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyVector(content()) &&
           verifier.VerifyVectorOfTables(content()) &&
           verifier.EndTable();
  }
  BundleCollectionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BundleCollection> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BundleCollectionBuilder {
  typedef BundleCollection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_content(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content) {
    fbb_.AddOffset(BundleCollection::VT_CONTENT, content);
  }
  explicit BundleCollectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BundleCollection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BundleCollection>(end);
    return o;
  }
};

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Fx::Bundle>>> content = 0) {
  BundleCollectionBuilder builder_(_fbb);
  builder_.add_content(content);
  return builder_.Finish();
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Fx::Bundle>> *content = nullptr) {
  auto content__ = content ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>>(*content) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      content__);
}

flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BundleSignatureT *BundleSignature::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleSignatureT>(new BundleSignatureT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleSignature::UnPackTo(BundleSignatureT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mode(); if (_e) _o->mode = _e->str(); }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = commithash(); if (_e) _o->commithash = _e->str(); }
  { auto _e = branch(); if (_e) _o->branch = _e->str(); }
  { auto _e = timestamp(); if (_e) _o->timestamp = _e->str(); }
}

inline flatbuffers::Offset<BundleSignature> BundleSignature::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleSignature(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleSignature> CreateBundleSignature(flatbuffers::FlatBufferBuilder &_fbb, const BundleSignatureT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleSignatureT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mode = _o->mode.empty() ? 0 : _fbb.CreateString(_o->mode);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _commithash = _o->commithash.empty() ? 0 : _fbb.CreateString(_o->commithash);
  auto _branch = _o->branch.empty() ? 0 : _fbb.CreateString(_o->branch);
  auto _timestamp = _o->timestamp.empty() ? 0 : _fbb.CreateString(_o->timestamp);
  return Fx::CreateBundleSignature(
      _fbb,
      _mode,
      _version,
      _commithash,
      _branch,
      _timestamp);
}

inline BundleMetaT *BundleMeta::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleMetaT>(new BundleMetaT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleMeta::UnPackTo(BundleMetaT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = author(); if (_e) _o->author = _e->str(); }
  { auto _e = source(); if (_e) _o->source = _e->str(); }
}

inline flatbuffers::Offset<BundleMeta> BundleMeta::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleMeta(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleMeta> CreateBundleMeta(flatbuffers::FlatBufferBuilder &_fbb, const BundleMetaT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleMetaT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _author = _o->author.empty() ? 0 : _fbb.CreateString(_o->author);
  auto _source = _o->source.empty() ? 0 : _fbb.CreateString(_o->source);
  return Fx::CreateBundleMeta(
      _fbb,
      _author,
      _source);
}

inline TypeFieldT::TypeFieldT(const TypeFieldT &o)
      : type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr),
        name(o.name),
        semantic(o.semantic),
        size(o.size),
        padding(o.padding) {
}

inline TypeFieldT &TypeFieldT::operator=(TypeFieldT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(name, o.name);
  std::swap(semantic, o.semantic);
  std::swap(size, o.size);
  std::swap(padding, o.padding);
  return *this;
}

inline TypeFieldT *TypeField::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeFieldT>(new TypeFieldT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeField::UnPackTo(TypeFieldT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = semantic(); if (_e) _o->semantic = _e->str(); }
  { auto _e = size(); _o->size = _e; }
  { auto _e = padding(); _o->padding = _e; }
}

inline flatbuffers::Offset<TypeField> TypeField::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeField(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeField> CreateTypeField(flatbuffers::FlatBufferBuilder &_fbb, const TypeFieldT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeFieldT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _semantic = _o->semantic.empty() ? 0 : _fbb.CreateString(_o->semantic);
  auto _size = _o->size;
  auto _padding = _o->padding;
  return Fx::CreateTypeField(
      _fbb,
      _type,
      _name,
      _semantic,
      _size,
      _padding);
}

inline TypeLayoutT::TypeLayoutT(const TypeLayoutT &o)
      : length(o.length),
        name(o.name),
        size(o.size) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new Fx::TypeFieldT(*fields_) : nullptr); }
}

inline TypeLayoutT &TypeLayoutT::operator=(TypeLayoutT o) FLATBUFFERS_NOEXCEPT {
  std::swap(fields, o.fields);
  std::swap(length, o.length);
  std::swap(name, o.name);
  std::swap(size, o.size);
  return *this;
}

inline TypeLayoutT *TypeLayout::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TypeLayoutT>(new TypeLayoutT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TypeLayout::UnPackTo(TypeLayoutT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fields[_i]) { _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver); } else { _o->fields[_i] = std::unique_ptr<Fx::TypeFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = length(); _o->length = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = size(); _o->size = _e; }
}

inline flatbuffers::Offset<TypeLayout> TypeLayout::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTypeLayout(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TypeLayout> CreateTypeLayout(flatbuffers::FlatBufferBuilder &_fbb, const TypeLayoutT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TypeLayoutT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateTypeField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _length = _o->length;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _size = _o->size;
  return Fx::CreateTypeLayout(
      _fbb,
      _fields,
      _length,
      _name,
      _size);
}

inline UAVBundleT::UAVBundleT(const UAVBundleT &o)
      : name(o.name),
        slot(o.slot),
        stride(o.stride),
        type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr) {
}

inline UAVBundleT &UAVBundleT::operator=(UAVBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(stride, o.stride);
  std::swap(type, o.type);
  return *this;
}

inline UAVBundleT *UAVBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UAVBundleT>(new UAVBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UAVBundle::UnPackTo(UAVBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<UAVBundle> UAVBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUAVBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UAVBundle> CreateUAVBundle(flatbuffers::FlatBufferBuilder &_fbb, const UAVBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UAVBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _stride = _o->stride;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  return Fx::CreateUAVBundle(
      _fbb,
      _name,
      _slot,
      _stride,
      _type);
}

inline BufferBundleT::BufferBundleT(const BufferBundleT &o)
      : name(o.name),
        slot(o.slot),
        stride(o.stride),
        type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr) {
}

inline BufferBundleT &BufferBundleT::operator=(BufferBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(stride, o.stride);
  std::swap(type, o.type);
  return *this;
}

inline BufferBundleT *BufferBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BufferBundleT>(new BufferBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BufferBundle::UnPackTo(BufferBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<BufferBundle> BufferBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BufferBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBufferBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BufferBundle> CreateBufferBundle(flatbuffers::FlatBufferBuilder &_fbb, const BufferBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BufferBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _stride = _o->stride;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  return Fx::CreateBufferBundle(
      _fbb,
      _name,
      _slot,
      _stride,
      _type);
}

inline TextureBundleT::TextureBundleT(const TextureBundleT &o)
      : name(o.name),
        slot(o.slot),
        stride(o.stride),
        type((o.type) ? new Fx::TypeLayoutT(*o.type) : nullptr) {
}

inline TextureBundleT &TextureBundleT::operator=(TextureBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(stride, o.stride);
  std::swap(type, o.type);
  return *this;
}

inline TextureBundleT *TextureBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TextureBundleT>(new TextureBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TextureBundle::UnPackTo(TextureBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = type(); if (_e) { if(_o->type) { _e->UnPackTo(_o->type.get(), _resolver); } else { _o->type = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<TextureBundle> TextureBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextureBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TextureBundle> CreateTextureBundle(flatbuffers::FlatBufferBuilder &_fbb, const TextureBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextureBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _stride = _o->stride;
  auto _type = _o->type ? CreateTypeLayout(_fbb, _o->type.get(), _rehasher) : 0;
  return Fx::CreateTextureBundle(
      _fbb,
      _name,
      _slot,
      _stride,
      _type);
}

inline TrimeshBundleT *TrimeshBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TrimeshBundleT>(new TrimeshBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TrimeshBundle::UnPackTo(TrimeshBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = vertexCountUName(); if (_e) _o->vertexCountUName = _e->str(); }
  { auto _e = faceCountUName(); if (_e) _o->faceCountUName = _e->str(); }
  { auto _e = verticesName(); if (_e) _o->verticesName = _e->str(); }
  { auto _e = facesName(); if (_e) _o->facesName = _e->str(); }
  { auto _e = gsAdjecencyName(); if (_e) _o->gsAdjecencyName = _e->str(); }
  { auto _e = faceAdjacencyName(); if (_e) _o->faceAdjacencyName = _e->str(); }
}

inline flatbuffers::Offset<TrimeshBundle> TrimeshBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TrimeshBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTrimeshBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TrimeshBundle> CreateTrimeshBundle(flatbuffers::FlatBufferBuilder &_fbb, const TrimeshBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TrimeshBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _vertexCountUName = _o->vertexCountUName.empty() ? 0 : _fbb.CreateString(_o->vertexCountUName);
  auto _faceCountUName = _o->faceCountUName.empty() ? 0 : _fbb.CreateString(_o->faceCountUName);
  auto _verticesName = _o->verticesName.empty() ? 0 : _fbb.CreateString(_o->verticesName);
  auto _facesName = _o->facesName.empty() ? 0 : _fbb.CreateString(_o->facesName);
  auto _gsAdjecencyName = _o->gsAdjecencyName.empty() ? 0 : _fbb.CreateString(_o->gsAdjecencyName);
  auto _faceAdjacencyName = _o->faceAdjacencyName.empty() ? 0 : _fbb.CreateString(_o->faceAdjacencyName);
  return Fx::CreateTrimeshBundle(
      _fbb,
      _name,
      _vertexCountUName,
      _faceCountUName,
      _verticesName,
      _facesName,
      _gsAdjecencyName,
      _faceAdjacencyName);
}

inline CBBundleT::CBBundleT(const CBBundleT &o)
      : name(o.name),
        slot(o.slot),
        size(o.size) {
  fields.reserve(o.fields.size());
  for (const auto &fields_ : o.fields) { fields.emplace_back((fields_) ? new Fx::TypeFieldT(*fields_) : nullptr); }
}

inline CBBundleT &CBBundleT::operator=(CBBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(slot, o.slot);
  std::swap(size, o.size);
  std::swap(fields, o.fields);
  return *this;
}

inline CBBundleT *CBBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CBBundleT>(new CBBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CBBundle::UnPackTo(CBBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = slot(); _o->slot = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = fields(); if (_e) { _o->fields.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->fields[_i]) { _e->Get(_i)->UnPackTo(_o->fields[_i].get(), _resolver); } else { _o->fields[_i] = std::unique_ptr<Fx::TypeFieldT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<CBBundle> CBBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CBBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCBBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CBBundle> CreateCBBundle(flatbuffers::FlatBufferBuilder &_fbb, const CBBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CBBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _slot = _o->slot;
  auto _size = _o->size;
  auto _fields = _o->fields.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TypeField>> (_o->fields.size(), [](size_t i, _VectorArgs *__va) { return CreateTypeField(*__va->__fbb, __va->__o->fields[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateCBBundle(
      _fbb,
      _name,
      _slot,
      _size,
      _fields);
}

inline GLSLAttributeT *GLSLAttribute::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GLSLAttributeT>(new GLSLAttributeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GLSLAttribute::UnPackTo(GLSLAttributeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = size(); _o->size = _e; }
  { auto _e = offset(); _o->offset = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline flatbuffers::Offset<GLSLAttribute> GLSLAttribute::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGLSLAttribute(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GLSLAttribute> CreateGLSLAttribute(flatbuffers::FlatBufferBuilder &_fbb, const GLSLAttributeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GLSLAttributeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _size = _o->size;
  auto _offset = _o->offset;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return Fx::CreateGLSLAttribute(
      _fbb,
      _size,
      _offset,
      _name);
}

inline RoutineBytecodeBundleResourcesT::RoutineBytecodeBundleResourcesT(const RoutineBytecodeBundleResourcesT &o) {
  uavs.reserve(o.uavs.size());
  for (const auto &uavs_ : o.uavs) { uavs.emplace_back((uavs_) ? new Fx::UAVBundleT(*uavs_) : nullptr); }
  buffers.reserve(o.buffers.size());
  for (const auto &buffers_ : o.buffers) { buffers.emplace_back((buffers_) ? new Fx::BufferBundleT(*buffers_) : nullptr); }
  textures.reserve(o.textures.size());
  for (const auto &textures_ : o.textures) { textures.emplace_back((textures_) ? new Fx::TextureBundleT(*textures_) : nullptr); }
  trimeshes.reserve(o.trimeshes.size());
  for (const auto &trimeshes_ : o.trimeshes) { trimeshes.emplace_back((trimeshes_) ? new Fx::TrimeshBundleT(*trimeshes_) : nullptr); }
}

inline RoutineBytecodeBundleResourcesT &RoutineBytecodeBundleResourcesT::operator=(RoutineBytecodeBundleResourcesT o) FLATBUFFERS_NOEXCEPT {
  std::swap(uavs, o.uavs);
  std::swap(buffers, o.buffers);
  std::swap(textures, o.textures);
  std::swap(trimeshes, o.trimeshes);
  return *this;
}

inline RoutineBytecodeBundleResourcesT *RoutineBytecodeBundleResources::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleResourcesT>(new RoutineBytecodeBundleResourcesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundleResources::UnPackTo(RoutineBytecodeBundleResourcesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uavs(); if (_e) { _o->uavs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->uavs[_i]) { _e->Get(_i)->UnPackTo(_o->uavs[_i].get(), _resolver); } else { _o->uavs[_i] = std::unique_ptr<Fx::UAVBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = buffers(); if (_e) { _o->buffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->buffers[_i]) { _e->Get(_i)->UnPackTo(_o->buffers[_i].get(), _resolver); } else { _o->buffers[_i] = std::unique_ptr<Fx::BufferBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = textures(); if (_e) { _o->textures.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->textures[_i]) { _e->Get(_i)->UnPackTo(_o->textures[_i].get(), _resolver); } else { _o->textures[_i] = std::unique_ptr<Fx::TextureBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = trimeshes(); if (_e) { _o->trimeshes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->trimeshes[_i]) { _e->Get(_i)->UnPackTo(_o->trimeshes[_i].get(), _resolver); } else { _o->trimeshes[_i] = std::unique_ptr<Fx::TrimeshBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> RoutineBytecodeBundleResources::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundleResources(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundleResources> CreateRoutineBytecodeBundleResources(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleResourcesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleResourcesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uavs = _o->uavs.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::UAVBundle>> (_o->uavs.size(), [](size_t i, _VectorArgs *__va) { return CreateUAVBundle(*__va->__fbb, __va->__o->uavs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _buffers = _o->buffers.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::BufferBundle>> (_o->buffers.size(), [](size_t i, _VectorArgs *__va) { return CreateBufferBundle(*__va->__fbb, __va->__o->buffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _textures = _o->textures.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TextureBundle>> (_o->textures.size(), [](size_t i, _VectorArgs *__va) { return CreateTextureBundle(*__va->__fbb, __va->__o->textures[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _trimeshes = _o->trimeshes.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::TrimeshBundle>> (_o->trimeshes.size(), [](size_t i, _VectorArgs *__va) { return CreateTrimeshBundle(*__va->__fbb, __va->__o->trimeshes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineBytecodeBundleResources(
      _fbb,
      _uavs,
      _buffers,
      _textures,
      _trimeshes);
}

inline RoutineBytecodeBundleT::RoutineBytecodeBundleT(const RoutineBytecodeBundleT &o)
      : code(o.code),
        resources((o.resources) ? new Fx::RoutineBytecodeBundleResourcesT(*o.resources) : nullptr),
        numthreads(o.numthreads) {
}

inline RoutineBytecodeBundleT &RoutineBytecodeBundleT::operator=(RoutineBytecodeBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(resources, o.resources);
  std::swap(numthreads, o.numthreads);
  return *this;
}

inline RoutineBytecodeBundleT *RoutineBytecodeBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineBytecodeBundleT>(new RoutineBytecodeBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineBytecodeBundle::UnPackTo(RoutineBytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) { _o->code.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->code.begin()); } }
  { auto _e = resources(); if (_e) { if(_o->resources) { _e->UnPackTo(_o->resources.get(), _resolver); } else { _o->resources = std::unique_ptr<Fx::RoutineBytecodeBundleResourcesT>(_e->UnPack(_resolver)); } } }
  { auto _e = numthreads(); if (_e) { _o->numthreads.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->numthreads[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<RoutineBytecodeBundle> RoutineBytecodeBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineBytecodeBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineBytecodeBundle> CreateRoutineBytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineBytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineBytecodeBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.size() ? _fbb.CreateVector(_o->code) : 0;
  auto _resources = _o->resources ? CreateRoutineBytecodeBundleResources(_fbb, _o->resources.get(), _rehasher) : 0;
  auto _numthreads = _o->numthreads.size() ? _fbb.CreateVector(_o->numthreads) : 0;
  return Fx::CreateRoutineBytecodeBundle(
      _fbb,
      _code,
      _resources,
      _numthreads);
}

inline Pass11BytecodeBundleT *Pass11BytecodeBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<Pass11BytecodeBundleT>(new Pass11BytecodeBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Pass11BytecodeBundle::UnPackTo(Pass11BytecodeBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) { _o->code.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->code.begin()); } }
}

inline flatbuffers::Offset<Pass11BytecodeBundle> Pass11BytecodeBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const Pass11BytecodeBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePass11BytecodeBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Pass11BytecodeBundle> CreatePass11BytecodeBundle(flatbuffers::FlatBufferBuilder &_fbb, const Pass11BytecodeBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const Pass11BytecodeBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.size() ? _fbb.CreateVector(_o->code) : 0;
  return Fx::CreatePass11BytecodeBundle(
      _fbb,
      _code);
}

inline RoutineGLSLSourceBundleT::RoutineGLSLSourceBundleT(const RoutineGLSLSourceBundleT &o)
      : code(o.code) {
  attributes.reserve(o.attributes.size());
  for (const auto &attributes_ : o.attributes) { attributes.emplace_back((attributes_) ? new Fx::GLSLAttributeT(*attributes_) : nullptr); }
  cbuffers.reserve(o.cbuffers.size());
  for (const auto &cbuffers_ : o.cbuffers) { cbuffers.emplace_back((cbuffers_) ? new Fx::CBBundleT(*cbuffers_) : nullptr); }
}

inline RoutineGLSLSourceBundleT &RoutineGLSLSourceBundleT::operator=(RoutineGLSLSourceBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(attributes, o.attributes);
  std::swap(cbuffers, o.cbuffers);
  return *this;
}

inline RoutineGLSLSourceBundleT *RoutineGLSLSourceBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineGLSLSourceBundleT>(new RoutineGLSLSourceBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineGLSLSourceBundle::UnPackTo(RoutineGLSLSourceBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = attributes(); if (_e) { _o->attributes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->attributes[_i]) { _e->Get(_i)->UnPackTo(_o->attributes[_i].get(), _resolver); } else { _o->attributes[_i] = std::unique_ptr<Fx::GLSLAttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = cbuffers(); if (_e) { _o->cbuffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cbuffers[_i]) { _e->Get(_i)->UnPackTo(_o->cbuffers[_i].get(), _resolver); } else { _o->cbuffers[_i] = std::unique_ptr<Fx::CBBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineGLSLSourceBundle> RoutineGLSLSourceBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLSourceBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineGLSLSourceBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineGLSLSourceBundle> CreateRoutineGLSLSourceBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineGLSLSourceBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineGLSLSourceBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _attributes = _o->attributes.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::GLSLAttribute>> (_o->attributes.size(), [](size_t i, _VectorArgs *__va) { return CreateGLSLAttribute(*__va->__fbb, __va->__o->attributes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _cbuffers = _o->cbuffers.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::CBBundle>> (_o->cbuffers.size(), [](size_t i, _VectorArgs *__va) { return CreateCBBundle(*__va->__fbb, __va->__o->cbuffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineGLSLSourceBundle(
      _fbb,
      _code,
      _attributes,
      _cbuffers);
}

inline RoutineHLSLSourceBundleT::RoutineHLSLSourceBundleT(const RoutineHLSLSourceBundleT &o)
      : code(o.code),
        entryName(o.entryName) {
  cbuffers.reserve(o.cbuffers.size());
  for (const auto &cbuffers_ : o.cbuffers) { cbuffers.emplace_back((cbuffers_) ? new Fx::CBBundleT(*cbuffers_) : nullptr); }
}

inline RoutineHLSLSourceBundleT &RoutineHLSLSourceBundleT::operator=(RoutineHLSLSourceBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(code, o.code);
  std::swap(entryName, o.entryName);
  std::swap(cbuffers, o.cbuffers);
  return *this;
}

inline RoutineHLSLSourceBundleT *RoutineHLSLSourceBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineHLSLSourceBundleT>(new RoutineHLSLSourceBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineHLSLSourceBundle::UnPackTo(RoutineHLSLSourceBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); }
  { auto _e = entryName(); if (_e) _o->entryName = _e->str(); }
  { auto _e = cbuffers(); if (_e) { _o->cbuffers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cbuffers[_i]) { _e->Get(_i)->UnPackTo(_o->cbuffers[_i].get(), _resolver); } else { _o->cbuffers[_i] = std::unique_ptr<Fx::CBBundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<RoutineHLSLSourceBundle> RoutineHLSLSourceBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineHLSLSourceBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineHLSLSourceBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineHLSLSourceBundle> CreateRoutineHLSLSourceBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineHLSLSourceBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineHLSLSourceBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _entryName = _o->entryName.empty() ? 0 : _fbb.CreateString(_o->entryName);
  auto _cbuffers = _o->cbuffers.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::CBBundle>> (_o->cbuffers.size(), [](size_t i, _VectorArgs *__va) { return CreateCBBundle(*__va->__fbb, __va->__o->cbuffers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateRoutineHLSLSourceBundle(
      _fbb,
      _code,
      _entryName,
      _cbuffers);
}

inline RoutineShaderBundleT *RoutineShaderBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RoutineShaderBundleT>(new RoutineShaderBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RoutineShaderBundle::UnPackTo(RoutineShaderBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shaders_type(); if (_e) { _o->shaders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shaders[_i].type = static_cast<Fx::RoutineSourceBundle>(_e->Get(_i)); } } }
  { auto _e = shaders(); if (_e) { _o->shaders.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shaders[_i].value = Fx::RoutineSourceBundleUnion::UnPack(_e->Get(_i), shaders_type()->GetEnum<RoutineSourceBundle>(_i), _resolver); } } }
}

inline flatbuffers::Offset<RoutineShaderBundle> RoutineShaderBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RoutineShaderBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRoutineShaderBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RoutineShaderBundle> CreateRoutineShaderBundle(flatbuffers::FlatBufferBuilder &_fbb, const RoutineShaderBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RoutineShaderBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shaders_type = _o->shaders.size() ? _fbb.CreateVector<uint8_t>(_o->shaders.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->shaders[i].type); }, &_va) : 0;
  auto _shaders = _o->shaders.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->shaders.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->shaders[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return Fx::CreateRoutineShaderBundle(
      _fbb,
      _shaders_type,
      _shaders);
}

inline PartRenderPassT::PartRenderPassT(const PartRenderPassT &o)
      : routines(o.routines),
        geometry(o.geometry),
        sorting(o.sorting),
        instanceCount(o.instanceCount),
        stride(o.stride),
        instance((o.instance) ? new Fx::TypeLayoutT(*o.instance) : nullptr) {
  renderStates.reserve(o.renderStates.size());
  for (const auto &renderStates_ : o.renderStates) { renderStates.emplace_back((renderStates_) ? new Fx::RenderStateT(*renderStates_) : nullptr); }
}

inline PartRenderPassT &PartRenderPassT::operator=(PartRenderPassT o) FLATBUFFERS_NOEXCEPT {
  std::swap(routines, o.routines);
  std::swap(geometry, o.geometry);
  std::swap(sorting, o.sorting);
  std::swap(instanceCount, o.instanceCount);
  std::swap(stride, o.stride);
  std::swap(instance, o.instance);
  std::swap(renderStates, o.renderStates);
  return *this;
}

inline PartRenderPassT *PartRenderPass::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartRenderPassT>(new PartRenderPassT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartRenderPass::UnPackTo(PartRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routines_type(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = routines(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), routines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = geometry(); if (_e) _o->geometry = _e->str(); }
  { auto _e = sorting(); _o->sorting = _e; }
  { auto _e = instanceCount(); _o->instanceCount = _e; }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = instance(); if (_e) { if(_o->instance) { _e->UnPackTo(_o->instance.get(), _resolver); } else { _o->instance = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
  { auto _e = renderStates(); if (_e) { _o->renderStates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderStates[_i]) { _e->Get(_i)->UnPackTo(_o->renderStates[_i].get(), _resolver); } else { _o->renderStates[_i] = std::unique_ptr<Fx::RenderStateT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<PartRenderPass> PartRenderPass::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartRenderPass(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartRenderPass> CreatePartRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const PartRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartRenderPassT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routines_type = _o->routines.size() ? _fbb.CreateVector<uint8_t>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->routines[i].type); }, &_va) : 0;
  auto _routines = _o->routines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->routines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _geometry = _o->geometry.empty() ? 0 : _fbb.CreateString(_o->geometry);
  auto _sorting = _o->sorting;
  auto _instanceCount = _o->instanceCount;
  auto _stride = _o->stride;
  auto _instance = _o->instance ? CreateTypeLayout(_fbb, _o->instance.get(), _rehasher) : 0;
  auto _renderStates = _o->renderStates.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::RenderState>> (_o->renderStates.size(), [](size_t i, _VectorArgs *__va) { return CreateRenderState(*__va->__fbb, __va->__o->renderStates[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreatePartRenderPass(
      _fbb,
      _routines_type,
      _routines,
      _geometry,
      _sorting,
      _instanceCount,
      _stride,
      _instance,
      _renderStates);
}

inline PartBundleT::PartBundleT(const PartBundleT &o)
      : capacity(o.capacity),
        simulationRoutines(o.simulationRoutines),
        particle((o.particle) ? new Fx::TypeLayoutT(*o.particle) : nullptr) {
  renderPasses.reserve(o.renderPasses.size());
  for (const auto &renderPasses_ : o.renderPasses) { renderPasses.emplace_back((renderPasses_) ? new Fx::PartRenderPassT(*renderPasses_) : nullptr); }
}

inline PartBundleT &PartBundleT::operator=(PartBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(capacity, o.capacity);
  std::swap(simulationRoutines, o.simulationRoutines);
  std::swap(renderPasses, o.renderPasses);
  std::swap(particle, o.particle);
  return *this;
}

inline PartBundleT *PartBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartBundleT>(new PartBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartBundle::UnPackTo(PartBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = capacity(); _o->capacity = _e; }
  { auto _e = simulationRoutines_type(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = simulationRoutines(); if (_e) { _o->simulationRoutines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->simulationRoutines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), simulationRoutines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = renderPasses(); if (_e) { _o->renderPasses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderPasses[_i]) { _e->Get(_i)->UnPackTo(_o->renderPasses[_i].get(), _resolver); } else { _o->renderPasses[_i] = std::unique_ptr<Fx::PartRenderPassT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = particle(); if (_e) { if(_o->particle) { _e->UnPackTo(_o->particle.get(), _resolver); } else { _o->particle = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<PartBundle> PartBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartBundle> CreatePartBundle(flatbuffers::FlatBufferBuilder &_fbb, const PartBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _capacity = _o->capacity;
  auto _simulationRoutines_type = _o->simulationRoutines.size() ? _fbb.CreateVector<uint8_t>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->simulationRoutines[i].type); }, &_va) : 0;
  auto _simulationRoutines = _o->simulationRoutines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->simulationRoutines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->simulationRoutines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _renderPasses = _o->renderPasses.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::PartRenderPass>> (_o->renderPasses.size(), [](size_t i, _VectorArgs *__va) { return CreatePartRenderPass(*__va->__fbb, __va->__o->renderPasses[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _particle = _o->particle ? CreateTypeLayout(_fbb, _o->particle.get(), _rehasher) : 0;
  return Fx::CreatePartBundle(
      _fbb,
      _capacity,
      _simulationRoutines_type,
      _simulationRoutines,
      _renderPasses,
      _particle);
}

inline RenderStateT *RenderState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RenderStateT>(new RenderStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RenderState::UnPackTo(RenderStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; }
  { auto _e = value(); _o->value = _e; }
}

inline flatbuffers::Offset<RenderState> RenderState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RenderStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRenderState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RenderState> CreateRenderState(flatbuffers::FlatBufferBuilder &_fbb, const RenderStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RenderStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _value = _o->value;
  return Fx::CreateRenderState(
      _fbb,
      _type,
      _value);
}

inline MatRenderPassT::MatRenderPassT(const MatRenderPassT &o)
      : routines(o.routines),
        instance((o.instance) ? new Fx::TypeLayoutT(*o.instance) : nullptr),
        stride(o.stride) {
  renderStates.reserve(o.renderStates.size());
  for (const auto &renderStates_ : o.renderStates) { renderStates.emplace_back((renderStates_) ? new Fx::RenderStateT(*renderStates_) : nullptr); }
}

inline MatRenderPassT &MatRenderPassT::operator=(MatRenderPassT o) FLATBUFFERS_NOEXCEPT {
  std::swap(routines, o.routines);
  std::swap(instance, o.instance);
  std::swap(stride, o.stride);
  std::swap(renderStates, o.renderStates);
  return *this;
}

inline MatRenderPassT *MatRenderPass::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatRenderPassT>(new MatRenderPassT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatRenderPass::UnPackTo(MatRenderPassT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = routines_type(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].type = static_cast<Fx::RoutineBundle>(_e->Get(_i)); } } }
  { auto _e = routines(); if (_e) { _o->routines.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->routines[_i].value = Fx::RoutineBundleUnion::UnPack(_e->Get(_i), routines_type()->GetEnum<RoutineBundle>(_i), _resolver); } } }
  { auto _e = instance(); if (_e) { if(_o->instance) { _e->UnPackTo(_o->instance.get(), _resolver); } else { _o->instance = std::unique_ptr<Fx::TypeLayoutT>(_e->UnPack(_resolver)); } } }
  { auto _e = stride(); _o->stride = _e; }
  { auto _e = renderStates(); if (_e) { _o->renderStates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderStates[_i]) { _e->Get(_i)->UnPackTo(_o->renderStates[_i].get(), _resolver); } else { _o->renderStates[_i] = std::unique_ptr<Fx::RenderStateT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<MatRenderPass> MatRenderPass::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatRenderPass(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatRenderPass> CreateMatRenderPass(flatbuffers::FlatBufferBuilder &_fbb, const MatRenderPassT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatRenderPassT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _routines_type = _o->routines.size() ? _fbb.CreateVector<uint8_t>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->routines[i].type); }, &_va) : 0;
  auto _routines = _o->routines.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->routines.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->routines[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  auto _instance = _o->instance ? CreateTypeLayout(_fbb, _o->instance.get(), _rehasher) : 0;
  auto _stride = _o->stride;
  auto _renderStates = _o->renderStates.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::RenderState>> (_o->renderStates.size(), [](size_t i, _VectorArgs *__va) { return CreateRenderState(*__va->__fbb, __va->__o->renderStates[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateMatRenderPass(
      _fbb,
      _routines_type,
      _routines,
      _instance,
      _stride,
      _renderStates);
}

inline MatBundleT::MatBundleT(const MatBundleT &o) {
  renderPasses.reserve(o.renderPasses.size());
  for (const auto &renderPasses_ : o.renderPasses) { renderPasses.emplace_back((renderPasses_) ? new Fx::MatRenderPassT(*renderPasses_) : nullptr); }
}

inline MatBundleT &MatBundleT::operator=(MatBundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(renderPasses, o.renderPasses);
  return *this;
}

inline MatBundleT *MatBundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MatBundleT>(new MatBundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MatBundle::UnPackTo(MatBundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = renderPasses(); if (_e) { _o->renderPasses.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->renderPasses[_i]) { _e->Get(_i)->UnPackTo(_o->renderPasses[_i].get(), _resolver); } else { _o->renderPasses[_i] = std::unique_ptr<Fx::MatRenderPassT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<MatBundle> MatBundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMatBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MatBundle> CreateMatBundle(flatbuffers::FlatBufferBuilder &_fbb, const MatBundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MatBundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _renderPasses = _o->renderPasses.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::MatRenderPass>> (_o->renderPasses.size(), [](size_t i, _VectorArgs *__va) { return CreateMatRenderPass(*__va->__fbb, __va->__o->renderPasses[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateMatBundle(
      _fbb,
      _renderPasses);
}

inline StringValueT *StringValue::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StringValueT>(new StringValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringValue::UnPackTo(StringValueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<StringValue> StringValue::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StringValueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StringValue> CreateStringValue(flatbuffers::FlatBufferBuilder &_fbb, const StringValueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StringValueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return Fx::CreateStringValue(
      _fbb,
      _value);
}

inline TextureValueT *TextureValue::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TextureValueT>(new TextureValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TextureValue::UnPackTo(TextureValueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<TextureValue> TextureValue::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TextureValueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTextureValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TextureValue> CreateTextureValue(flatbuffers::FlatBufferBuilder &_fbb, const TextureValueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TextureValueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return Fx::CreateTextureValue(
      _fbb,
      _value);
}

inline MeshValueT *MeshValue::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MeshValueT>(new MeshValueT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MeshValue::UnPackTo(MeshValueT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<MeshValue> MeshValue::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshValueT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshValue(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshValue> CreateMeshValue(flatbuffers::FlatBufferBuilder &_fbb, const MeshValueT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshValueT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = _o->value.empty() ? 0 : _fbb.CreateString(_o->value);
  return Fx::CreateMeshValue(
      _fbb,
      _value);
}

inline ViewTypePropertyT *ViewTypeProperty::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ViewTypePropertyT>(new ViewTypePropertyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ViewTypeProperty::UnPackTo(ViewTypePropertyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = Fx::PropertyValueUnion::UnPack(_e, value_type(), _resolver); }
}

inline flatbuffers::Offset<ViewTypeProperty> ViewTypeProperty::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ViewTypePropertyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateViewTypeProperty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ViewTypeProperty> CreateViewTypeProperty(flatbuffers::FlatBufferBuilder &_fbb, const ViewTypePropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ViewTypePropertyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return Fx::CreateViewTypeProperty(
      _fbb,
      _name,
      _value_type,
      _value);
}

inline UIControlT::UIControlT(const UIControlT &o)
      : name(o.name),
        value(o.value) {
  properties.reserve(o.properties.size());
  for (const auto &properties_ : o.properties) { properties.emplace_back((properties_) ? new Fx::ViewTypePropertyT(*properties_) : nullptr); }
}

inline UIControlT &UIControlT::operator=(UIControlT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(value, o.value);
  std::swap(properties, o.properties);
  return *this;
}

inline UIControlT *UIControl::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UIControlT>(new UIControlT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UIControl::UnPackTo(UIControlT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = Fx::ControlValueUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = properties(); if (_e) { _o->properties.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->properties[_i]) { _e->Get(_i)->UnPackTo(_o->properties[_i].get(), _resolver); } else { _o->properties[_i] = std::unique_ptr<Fx::ViewTypePropertyT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<UIControl> UIControl::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUIControl(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UIControl> CreateUIControl(flatbuffers::FlatBufferBuilder &_fbb, const UIControlT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UIControlT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _properties = _o->properties.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::ViewTypeProperty>> (_o->properties.size(), [](size_t i, _VectorArgs *__va) { return CreateViewTypeProperty(*__va->__fbb, __va->__o->properties[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateUIControl(
      _fbb,
      _name,
      _value_type,
      _value,
      _properties);
}

inline PresetEntryT *PresetEntry::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PresetEntryT>(new PresetEntryT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PresetEntry::UnPackTo(PresetEntryT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = Fx::ControlValueUnion::UnPack(_e, value_type(), _resolver); }
}

inline flatbuffers::Offset<PresetEntry> PresetEntry::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePresetEntry(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PresetEntry> CreatePresetEntry(flatbuffers::FlatBufferBuilder &_fbb, const PresetEntryT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PresetEntryT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return Fx::CreatePresetEntry(
      _fbb,
      _name,
      _value_type,
      _value);
}

inline PresetT::PresetT(const PresetT &o)
      : name(o.name),
        desc(o.desc) {
  data.reserve(o.data.size());
  for (const auto &data_ : o.data) { data.emplace_back((data_) ? new Fx::PresetEntryT(*data_) : nullptr); }
}

inline PresetT &PresetT::operator=(PresetT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(desc, o.desc);
  std::swap(data, o.data);
  return *this;
}

inline PresetT *Preset::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PresetT>(new PresetT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Preset::UnPackTo(PresetT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = desc(); if (_e) _o->desc = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->data[_i]) { _e->Get(_i)->UnPackTo(_o->data[_i].get(), _resolver); } else { _o->data[_i] = std::unique_ptr<Fx::PresetEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Preset> Preset::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PresetT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePreset(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Preset> CreatePreset(flatbuffers::FlatBufferBuilder &_fbb, const PresetT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PresetT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::PresetEntry>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreatePresetEntry(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreatePreset(
      _fbb,
      _name,
      _desc,
      _data);
}

inline BundleT::BundleT(const BundleT &o)
      : name(o.name),
        signature((o.signature) ? new Fx::BundleSignatureT(*o.signature) : nullptr),
        meta((o.meta) ? new Fx::BundleMetaT(*o.meta) : nullptr),
        content(o.content) {
  controls.reserve(o.controls.size());
  for (const auto &controls_ : o.controls) { controls.emplace_back((controls_) ? new Fx::UIControlT(*controls_) : nullptr); }
  presets.reserve(o.presets.size());
  for (const auto &presets_ : o.presets) { presets.emplace_back((presets_) ? new Fx::PresetT(*presets_) : nullptr); }
}

inline BundleT &BundleT::operator=(BundleT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(signature, o.signature);
  std::swap(meta, o.meta);
  std::swap(content, o.content);
  std::swap(controls, o.controls);
  std::swap(presets, o.presets);
  return *this;
}

inline BundleT *Bundle::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleT>(new BundleT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Bundle::UnPackTo(BundleT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = signature(); if (_e) { if(_o->signature) { _e->UnPackTo(_o->signature.get(), _resolver); } else { _o->signature = std::unique_ptr<Fx::BundleSignatureT>(_e->UnPack(_resolver)); } } }
  { auto _e = meta(); if (_e) { if(_o->meta) { _e->UnPackTo(_o->meta.get(), _resolver); } else { _o->meta = std::unique_ptr<Fx::BundleMetaT>(_e->UnPack(_resolver)); } } }
  { auto _e = content_type(); _o->content.type = _e; }
  { auto _e = content(); if (_e) _o->content.value = Fx::BundleContentUnion::UnPack(_e, content_type(), _resolver); }
  { auto _e = controls(); if (_e) { _o->controls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->controls[_i]) { _e->Get(_i)->UnPackTo(_o->controls[_i].get(), _resolver); } else { _o->controls[_i] = std::unique_ptr<Fx::UIControlT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = presets(); if (_e) { _o->presets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->presets[_i]) { _e->Get(_i)->UnPackTo(_o->presets[_i].get(), _resolver); } else { _o->presets[_i] = std::unique_ptr<Fx::PresetT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Bundle> Bundle::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundle(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Bundle> CreateBundle(flatbuffers::FlatBufferBuilder &_fbb, const BundleT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _signature = _o->signature ? CreateBundleSignature(_fbb, _o->signature.get(), _rehasher) : 0;
  auto _meta = _o->meta ? CreateBundleMeta(_fbb, _o->meta.get(), _rehasher) : 0;
  auto _content_type = _o->content.type;
  auto _content = _o->content.Pack(_fbb);
  auto _controls = _o->controls.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::UIControl>> (_o->controls.size(), [](size_t i, _VectorArgs *__va) { return CreateUIControl(*__va->__fbb, __va->__o->controls[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _presets = _o->presets.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::Preset>> (_o->presets.size(), [](size_t i, _VectorArgs *__va) { return CreatePreset(*__va->__fbb, __va->__o->presets[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateBundle(
      _fbb,
      _name,
      _signature,
      _meta,
      _content_type,
      _content,
      _controls,
      _presets);
}

inline BundleCollectionT::BundleCollectionT(const BundleCollectionT &o) {
  content.reserve(o.content.size());
  for (const auto &content_ : o.content) { content.emplace_back((content_) ? new Fx::BundleT(*content_) : nullptr); }
}

inline BundleCollectionT &BundleCollectionT::operator=(BundleCollectionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(content, o.content);
  return *this;
}

inline BundleCollectionT *BundleCollection::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<BundleCollectionT>(new BundleCollectionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BundleCollection::UnPackTo(BundleCollectionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = content(); if (_e) { _o->content.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->content[_i]) { _e->Get(_i)->UnPackTo(_o->content[_i].get(), _resolver); } else { _o->content[_i] = std::unique_ptr<Fx::BundleT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<BundleCollection> BundleCollection::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBundleCollection(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BundleCollection> CreateBundleCollection(flatbuffers::FlatBufferBuilder &_fbb, const BundleCollectionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BundleCollectionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _content = _o->content.size() ? _fbb.CreateVector<flatbuffers::Offset<Fx::Bundle>> (_o->content.size(), [](size_t i, _VectorArgs *__va) { return CreateBundle(*__va->__fbb, __va->__o->content[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Fx::CreateBundleCollection(
      _fbb,
      _content);
}

inline bool VerifyRoutineBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineBundle type) {
  switch (type) {
    case RoutineBundle_NONE: {
      return true;
    }
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RoutineBundle_RoutineShaderBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineShaderBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRoutineBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRoutineBundle(
        verifier,  values->Get(i), types->GetEnum<RoutineBundle>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RoutineBundleUnion::UnPack(const void *obj, RoutineBundle type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case RoutineBundle_RoutineShaderBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineShaderBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RoutineBundleUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineBytecodeBundleT *>(value);
      return CreateRoutineBytecodeBundle(_fbb, ptr, _rehasher).Union();
    }
    case RoutineBundle_RoutineShaderBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineShaderBundleT *>(value);
      return CreateRoutineShaderBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RoutineBundleUnion::RoutineBundleUnion(const RoutineBundleUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      value = new Fx::RoutineBytecodeBundleT(*reinterpret_cast<Fx::RoutineBytecodeBundleT *>(u.value));
      break;
    }
    case RoutineBundle_RoutineShaderBundle: {
      value = new Fx::RoutineShaderBundleT(*reinterpret_cast<Fx::RoutineShaderBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RoutineBundleUnion::Reset() {
  switch (type) {
    case RoutineBundle_RoutineBytecodeBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineBytecodeBundleT *>(value);
      delete ptr;
      break;
    }
    case RoutineBundle_RoutineShaderBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineShaderBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = RoutineBundle_NONE;
}

inline bool VerifyRoutineSourceBundle(flatbuffers::Verifier &verifier, const void *obj, RoutineSourceBundle type) {
  switch (type) {
    case RoutineSourceBundle_NONE: {
      return true;
    }
    case RoutineSourceBundle_RoutineGLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLSourceBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case RoutineSourceBundle_RoutineHLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineHLSLSourceBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyRoutineSourceBundleVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyRoutineSourceBundle(
        verifier,  values->Get(i), types->GetEnum<RoutineSourceBundle>(i))) {
      return false;
    }
  }
  return true;
}

inline void *RoutineSourceBundleUnion::UnPack(const void *obj, RoutineSourceBundle type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case RoutineSourceBundle_RoutineGLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLSourceBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case RoutineSourceBundle_RoutineHLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineHLSLSourceBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> RoutineSourceBundleUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case RoutineSourceBundle_RoutineGLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineGLSLSourceBundleT *>(value);
      return CreateRoutineGLSLSourceBundle(_fbb, ptr, _rehasher).Union();
    }
    case RoutineSourceBundle_RoutineHLSLSourceBundle: {
      auto ptr = reinterpret_cast<const Fx::RoutineHLSLSourceBundleT *>(value);
      return CreateRoutineHLSLSourceBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline RoutineSourceBundleUnion::RoutineSourceBundleUnion(const RoutineSourceBundleUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case RoutineSourceBundle_RoutineGLSLSourceBundle: {
      value = new Fx::RoutineGLSLSourceBundleT(*reinterpret_cast<Fx::RoutineGLSLSourceBundleT *>(u.value));
      break;
    }
    case RoutineSourceBundle_RoutineHLSLSourceBundle: {
      value = new Fx::RoutineHLSLSourceBundleT(*reinterpret_cast<Fx::RoutineHLSLSourceBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void RoutineSourceBundleUnion::Reset() {
  switch (type) {
    case RoutineSourceBundle_RoutineGLSLSourceBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineGLSLSourceBundleT *>(value);
      delete ptr;
      break;
    }
    case RoutineSourceBundle_RoutineHLSLSourceBundle: {
      auto ptr = reinterpret_cast<Fx::RoutineHLSLSourceBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = RoutineSourceBundle_NONE;
}

inline bool VerifyBundleContent(flatbuffers::Verifier &verifier, const void *obj, BundleContent type) {
  switch (type) {
    case BundleContent_NONE: {
      return true;
    }
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyBundleContentVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBundleContent(
        verifier,  values->Get(i), types->GetEnum<BundleContent>(i))) {
      return false;
    }
  }
  return true;
}

inline void *BundleContentUnion::UnPack(const void *obj, BundleContent type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundle *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> BundleContentUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<const Fx::PartBundleT *>(value);
      return CreatePartBundle(_fbb, ptr, _rehasher).Union();
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<const Fx::MatBundleT *>(value);
      return CreateMatBundle(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline BundleContentUnion::BundleContentUnion(const BundleContentUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case BundleContent_PartBundle: {
      value = new Fx::PartBundleT(*reinterpret_cast<Fx::PartBundleT *>(u.value));
      break;
    }
    case BundleContent_MatBundle: {
      value = new Fx::MatBundleT(*reinterpret_cast<Fx::MatBundleT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void BundleContentUnion::Reset() {
  switch (type) {
    case BundleContent_PartBundle: {
      auto ptr = reinterpret_cast<Fx::PartBundleT *>(value);
      delete ptr;
      break;
    }
    case BundleContent_MatBundle: {
      auto ptr = reinterpret_cast<Fx::MatBundleT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = BundleContent_NONE;
}

inline bool VerifyPropertyValue(flatbuffers::Verifier &verifier, const void *obj, PropertyValue type) {
  switch (type) {
    case PropertyValue_NONE: {
      return true;
    }
    case PropertyValue_UintValue: {
      return verifier.VerifyField<Fx::UintValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case PropertyValue_IntValue: {
      return verifier.VerifyField<Fx::IntValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case PropertyValue_FloatValue: {
      return verifier.VerifyField<Fx::FloatValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case PropertyValue_StringValue: {
      auto ptr = reinterpret_cast<const Fx::StringValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPropertyValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPropertyValue(
        verifier,  values->Get(i), types->GetEnum<PropertyValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PropertyValueUnion::UnPack(const void *obj, PropertyValue type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case PropertyValue_UintValue: {
      auto ptr = reinterpret_cast<const Fx::UintValue *>(obj);
      return new Fx::UintValue(*ptr);
    }
    case PropertyValue_IntValue: {
      auto ptr = reinterpret_cast<const Fx::IntValue *>(obj);
      return new Fx::IntValue(*ptr);
    }
    case PropertyValue_FloatValue: {
      auto ptr = reinterpret_cast<const Fx::FloatValue *>(obj);
      return new Fx::FloatValue(*ptr);
    }
    case PropertyValue_StringValue: {
      auto ptr = reinterpret_cast<const Fx::StringValue *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PropertyValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case PropertyValue_UintValue: {
      auto ptr = reinterpret_cast<const Fx::UintValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case PropertyValue_IntValue: {
      auto ptr = reinterpret_cast<const Fx::IntValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case PropertyValue_FloatValue: {
      auto ptr = reinterpret_cast<const Fx::FloatValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case PropertyValue_StringValue: {
      auto ptr = reinterpret_cast<const Fx::StringValueT *>(value);
      return CreateStringValue(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PropertyValueUnion::PropertyValueUnion(const PropertyValueUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case PropertyValue_UintValue: {
      value = new Fx::UintValue(*reinterpret_cast<Fx::UintValue *>(u.value));
      break;
    }
    case PropertyValue_IntValue: {
      value = new Fx::IntValue(*reinterpret_cast<Fx::IntValue *>(u.value));
      break;
    }
    case PropertyValue_FloatValue: {
      value = new Fx::FloatValue(*reinterpret_cast<Fx::FloatValue *>(u.value));
      break;
    }
    case PropertyValue_StringValue: {
      value = new Fx::StringValueT(*reinterpret_cast<Fx::StringValueT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PropertyValueUnion::Reset() {
  switch (type) {
    case PropertyValue_UintValue: {
      auto ptr = reinterpret_cast<Fx::UintValue *>(value);
      delete ptr;
      break;
    }
    case PropertyValue_IntValue: {
      auto ptr = reinterpret_cast<Fx::IntValue *>(value);
      delete ptr;
      break;
    }
    case PropertyValue_FloatValue: {
      auto ptr = reinterpret_cast<Fx::FloatValue *>(value);
      delete ptr;
      break;
    }
    case PropertyValue_StringValue: {
      auto ptr = reinterpret_cast<Fx::StringValueT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = PropertyValue_NONE;
}

inline bool VerifyControlValue(flatbuffers::Verifier &verifier, const void *obj, ControlValue type) {
  switch (type) {
    case ControlValue_NONE: {
      return true;
    }
    case ControlValue_UintValue: {
      return verifier.VerifyField<Fx::UintValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_IntValue: {
      return verifier.VerifyField<Fx::IntValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_FloatValue: {
      return verifier.VerifyField<Fx::FloatValue>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_Float2Value: {
      return verifier.VerifyField<Fx::Float2Value>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_Float3Value: {
      return verifier.VerifyField<Fx::Float3Value>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_Float4Value: {
      return verifier.VerifyField<Fx::Float4Value>(static_cast<const uint8_t *>(obj), 0, 4);
    }
    case ControlValue_ColorValue: {
      return verifier.VerifyField<Fx::ColorValue>(static_cast<const uint8_t *>(obj), 0, 1);
    }
    case ControlValue_TextureValue: {
      auto ptr = reinterpret_cast<const Fx::TextureValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ControlValue_MeshValue: {
      auto ptr = reinterpret_cast<const Fx::MeshValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyControlValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyControlValue(
        verifier,  values->Get(i), types->GetEnum<ControlValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ControlValueUnion::UnPack(const void *obj, ControlValue type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ControlValue_UintValue: {
      auto ptr = reinterpret_cast<const Fx::UintValue *>(obj);
      return new Fx::UintValue(*ptr);
    }
    case ControlValue_IntValue: {
      auto ptr = reinterpret_cast<const Fx::IntValue *>(obj);
      return new Fx::IntValue(*ptr);
    }
    case ControlValue_FloatValue: {
      auto ptr = reinterpret_cast<const Fx::FloatValue *>(obj);
      return new Fx::FloatValue(*ptr);
    }
    case ControlValue_Float2Value: {
      auto ptr = reinterpret_cast<const Fx::Float2Value *>(obj);
      return new Fx::Float2Value(*ptr);
    }
    case ControlValue_Float3Value: {
      auto ptr = reinterpret_cast<const Fx::Float3Value *>(obj);
      return new Fx::Float3Value(*ptr);
    }
    case ControlValue_Float4Value: {
      auto ptr = reinterpret_cast<const Fx::Float4Value *>(obj);
      return new Fx::Float4Value(*ptr);
    }
    case ControlValue_ColorValue: {
      auto ptr = reinterpret_cast<const Fx::ColorValue *>(obj);
      return new Fx::ColorValue(*ptr);
    }
    case ControlValue_TextureValue: {
      auto ptr = reinterpret_cast<const Fx::TextureValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ControlValue_MeshValue: {
      auto ptr = reinterpret_cast<const Fx::MeshValue *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ControlValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ControlValue_UintValue: {
      auto ptr = reinterpret_cast<const Fx::UintValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_IntValue: {
      auto ptr = reinterpret_cast<const Fx::IntValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_FloatValue: {
      auto ptr = reinterpret_cast<const Fx::FloatValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_Float2Value: {
      auto ptr = reinterpret_cast<const Fx::Float2Value *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_Float3Value: {
      auto ptr = reinterpret_cast<const Fx::Float3Value *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_Float4Value: {
      auto ptr = reinterpret_cast<const Fx::Float4Value *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_ColorValue: {
      auto ptr = reinterpret_cast<const Fx::ColorValue *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case ControlValue_TextureValue: {
      auto ptr = reinterpret_cast<const Fx::TextureValueT *>(value);
      return CreateTextureValue(_fbb, ptr, _rehasher).Union();
    }
    case ControlValue_MeshValue: {
      auto ptr = reinterpret_cast<const Fx::MeshValueT *>(value);
      return CreateMeshValue(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ControlValueUnion::ControlValueUnion(const ControlValueUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ControlValue_UintValue: {
      value = new Fx::UintValue(*reinterpret_cast<Fx::UintValue *>(u.value));
      break;
    }
    case ControlValue_IntValue: {
      value = new Fx::IntValue(*reinterpret_cast<Fx::IntValue *>(u.value));
      break;
    }
    case ControlValue_FloatValue: {
      value = new Fx::FloatValue(*reinterpret_cast<Fx::FloatValue *>(u.value));
      break;
    }
    case ControlValue_Float2Value: {
      value = new Fx::Float2Value(*reinterpret_cast<Fx::Float2Value *>(u.value));
      break;
    }
    case ControlValue_Float3Value: {
      value = new Fx::Float3Value(*reinterpret_cast<Fx::Float3Value *>(u.value));
      break;
    }
    case ControlValue_Float4Value: {
      value = new Fx::Float4Value(*reinterpret_cast<Fx::Float4Value *>(u.value));
      break;
    }
    case ControlValue_ColorValue: {
      value = new Fx::ColorValue(*reinterpret_cast<Fx::ColorValue *>(u.value));
      break;
    }
    case ControlValue_TextureValue: {
      value = new Fx::TextureValueT(*reinterpret_cast<Fx::TextureValueT *>(u.value));
      break;
    }
    case ControlValue_MeshValue: {
      value = new Fx::MeshValueT(*reinterpret_cast<Fx::MeshValueT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ControlValueUnion::Reset() {
  switch (type) {
    case ControlValue_UintValue: {
      auto ptr = reinterpret_cast<Fx::UintValue *>(value);
      delete ptr;
      break;
    }
    case ControlValue_IntValue: {
      auto ptr = reinterpret_cast<Fx::IntValue *>(value);
      delete ptr;
      break;
    }
    case ControlValue_FloatValue: {
      auto ptr = reinterpret_cast<Fx::FloatValue *>(value);
      delete ptr;
      break;
    }
    case ControlValue_Float2Value: {
      auto ptr = reinterpret_cast<Fx::Float2Value *>(value);
      delete ptr;
      break;
    }
    case ControlValue_Float3Value: {
      auto ptr = reinterpret_cast<Fx::Float3Value *>(value);
      delete ptr;
      break;
    }
    case ControlValue_Float4Value: {
      auto ptr = reinterpret_cast<Fx::Float4Value *>(value);
      delete ptr;
      break;
    }
    case ControlValue_ColorValue: {
      auto ptr = reinterpret_cast<Fx::ColorValue *>(value);
      delete ptr;
      break;
    }
    case ControlValue_TextureValue: {
      auto ptr = reinterpret_cast<Fx::TextureValueT *>(value);
      delete ptr;
      break;
    }
    case ControlValue_MeshValue: {
      auto ptr = reinterpret_cast<Fx::MeshValueT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ControlValue_NONE;
}

inline const Fx::Bundle *GetBundle(const void *buf) {
  return flatbuffers::GetRoot<Fx::Bundle>(buf);
}

inline const Fx::Bundle *GetSizePrefixedBundle(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Fx::Bundle>(buf);
}

inline bool VerifyBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Fx::Bundle>(nullptr);
}

inline bool VerifySizePrefixedBundleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Fx::Bundle>(nullptr);
}

inline void FinishBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBundleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Fx::Bundle> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Fx::BundleT> UnPackBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetBundle(buf)->UnPack(res));
}

inline std::unique_ptr<Fx::BundleT> UnPackSizePrefixedBundle(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Fx::BundleT>(GetSizePrefixedBundle(buf)->UnPack(res));
}

}  // namespace Fx

#endif  // FLATBUFFERS_GENERATED_FXBUNDLE_FX_H_
